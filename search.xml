<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NotePadNext：简介和源码编译</title>
      <link href="/2022/10/07/OpenSourceProjects/NotePadNext/NotePadNext-1-%E7%AE%80%E4%BB%8B%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/2022/10/07/OpenSourceProjects/NotePadNext/NotePadNext-1-%E7%AE%80%E4%BB%8B%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="NotePadNext-介绍">NotePadNext 介绍</h2><blockquote><p>A cross-platform, reimplementation of Notepad++.</p><p>Though the application overall is stable and usable, it should not &gt; be considered safe for critically important work.</p><p>There are numerous bugs and half working implementations. Pull requests are greatly appreciated.</p></blockquote><p>通过下面链接可以获取更多的相关信息：<br><a href="https://github.com/dail8859/NotepadNext">https://github.com/dail8859/NotepadNext</a></p><h2 id="源码编译">源码编译</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 克隆源码及子模块的源码</span><br><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/dail8859/NotepadNext.git</span><br></pre></td></tr></table></figure><p>使用 QtCreator 打开 <code>NotePadNext/src/NotepadNext.pro</code>，点击编译或运行。</p><p><img src="/assets/images/NotePadNext-run.png" alt="NotePadNext-run"></p>]]></content>
      
      
      <categories>
          
          <category> NotePadNext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> NotePadNext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NotePadNext：序</title>
      <link href="/2022/10/07/OpenSourceProjects/NotePadNext/NotePadNext-0-%E5%BA%8F/"/>
      <url>/2022/10/07/OpenSourceProjects/NotePadNext/NotePadNext-0-%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>缘由：</p><ul><li>想看看外国佬是如何使用 Qt 开发开源项目</li><li>目前所学所作也是 Qt</li></ul><p>本着学习和提升的目的，开始写 NotePadNext 源码分析文章。</p><h2 id="目录">目录</h2><!-- markdown 的语法在 Hexo 中不兼容[Qt Creator 源码分析-1-环境配置](../QtCreator源码分析-1-环境配置)[Qt Creator 源码分析-2-目录分析](../QtCreator源码分析-2-目录分析)[Qt Creator 源码分析-3-程序入口](../QtCreator源码分析-3-程序入口)[Qt Creator 源码分析-4-main() 函数分析](../QtCreator源码分析-4-main()函数分析)--><!-- <a href="#">Post not found: _posts-subpath/文章文件名（不要后缀） 文章标题（可选）</a> --><ul><li><a href="/2022/10/07/OpenSourceProjects/NotePadNext/NotePadNext-0-%E5%BA%8F/" title="NotePadNext-0-序">NotePadNext-0-序</a></li><li><a href="/2022/10/07/OpenSourceProjects/NotePadNext/NotePadNext-1-%E7%AE%80%E4%BB%8B%E5%92%8C%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/" title="NotePadNext-1-简介和源码编译">NotePadNext-1-简介和源码编译</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> NotePadNext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> NotePadNext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt问题-QtCreator调试程序问题</title>
      <link href="/2022/10/07/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-QtCreator%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/07/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-QtCreator%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="QtCreator-无法调试程序-操作系统位数不对">QtCreator 无法调试程序 操作系统位数不对</h2><p>qtcreator is a 64 bit executable which can not be debugged by a 32 bit Debugger</p><p><img src="/assets/images/QtProblems-qtcreator-debug-error.png" alt="QtProblems-qtcreator-debug-error"></p>]]></content>
      
      
      <categories>
          
          <category> QtProblems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtProblems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把寒冬传递给每一个穷人</title>
      <link href="/2022/09/19/%E6%9D%82%E8%AE%B0/%E6%8A%8A%E5%AF%92%E5%86%AC%E4%BC%A0%E9%80%92%E7%BB%99%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A9%B7%E4%BA%BA/"/>
      <url>/2022/09/19/%E6%9D%82%E8%AE%B0/%E6%8A%8A%E5%AF%92%E5%86%AC%E4%BC%A0%E9%80%92%E7%BB%99%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A9%B7%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：线程</title>
      <link href="/2022/09/13/C++/C++Feature/1.33.C++11-thread/"/>
      <url>/2022/09/13/C++/C++Feature/1.33.C++11-thread/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98 实现的多线程，依赖第三方库 pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100000000L</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;m);</span><br><span class="line">        total += i;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line">    <span class="keyword">if</span>  (<span class="built_in">pthread_create</span>(&amp;thread1, <span class="literal">NULL</span>, &amp;func, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thread2, <span class="literal">NULL</span>, &amp;func, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(thread1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 实现的多线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">atomic_llong total&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000LL</span>; ++i) &#123;</span><br><span class="line">        total += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func ,<span class="number">0</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：tuple(元组)</title>
      <link href="/2022/09/13/C++/C++Feature/1.34.C++11-tuple/"/>
      <url>/2022/09/13/C++/C++Feature/1.34.C++11-tuple/</url>
      
        <content type="html"><![CDATA[<h2 id="tuple-元组">tuple(元组)</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>tuple_size</code></td><td>实现固定大小的容器，它保有类型可以相异的元素</td></tr><tr><td><code>tuple_element</code></td><td>获得元组式类型的元素数</td></tr><tr><td><code>std::tuple_size&lt;std::tuple&gt;</code></td><td>获得元组式类型的元素类型</td></tr><tr><td><code>std::tuple_element&lt;std::tuple&gt;</code></td><td>获得指定元素的类型</td></tr><tr><td><code>std::uses_allocator&lt;std::tuple&gt;</code></td><td>特化 std::uses_allocator 类型特征</td></tr><tr><td><code>ignore</code>（常量）</td><td>用 tie 解包 tuple 时用来跳过元素的占位符</td></tr><tr><td><code>make_tuple</code></td><td>创建一个 tuple 对象，其类型根据各实参类型定义</td></tr><tr><td><code>tie</code></td><td>创建左值引用的 tuple，或将 tuple 解包为独立对象</td></tr><tr><td><code>forward_as_tuple</code></td><td>创建转发引用的 tupl</td></tr><tr><td><code>tuple_cat</code></td><td>通过连接任意数量的元组来创建一个tuple</td></tr><tr><td><code>std::get(std::tuple)</code></td><td>元组式访问指定的元素</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：智能指针</title>
      <link href="/2022/09/13/C++/C++Feature/1.32.C++11-smart_pointer/"/>
      <url>/2022/09/13/C++/C++Feature/1.32.C++11-smart_pointer/</url>
      
        <content type="html"><![CDATA[<p>C++ 11 中有 <code>unique_ptr</code>、<code>shared_ptr</code> 与 <code>weak_ptr</code> 等智能指针(smart pointer)，定义在<code>&lt;memory&gt;</code>中。可以对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</p><table><thead><tr><th>名词</th><th>描述</th></tr></thead><tbody><tr><td>unique_ptr</td><td>拥有管理内存的所有权，没有拷贝构造函数，只有移动构造函数，不能多个unique_ptr对象共享一段内存，可以自定义delete函数，从而支持delete [] 。</td></tr><tr><td>share_ptr</td><td>通过计数方式多个share_ptr可以共享一段内存，当计数为0的时候，所管理内存会被删除，可以自定义delete函数，从而支持delete[]。</td></tr><tr><td>weak_ptr</td><td>观察shared_ptr管理的内存对象 ，只观察但不拥有。成员函数lock返回shared_ptr对象，若对应内存已经删除，则shared_ptr对象==nullptr，weak_ptr对象可以拷贝构造，拷贝构造出来的对象和原对象观察的是同一段内存。成员函数reset可以解除对内存的观察，注意，是解除观察，并不会删除对应内存对象。可以避免因shared_ptr的循环引用而引起的内存泄露，见如下对比使用方式：</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;<span class="keyword">class</span> <span class="title class_">B</span>&gt; m_spB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        shared_ptr&lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt; m_spA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        weak_ptr&lt;<span class="keyword">class</span> <span class="title class_">D</span>&gt; m_wpD;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        weak_ptr&lt;<span class="keyword">class</span> <span class="title class_">C</span>&gt; m_wpC;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_loop_ref</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    weak_ptr&lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt; wp1;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pA = <span class="built_in">make_shared</span>&lt;<span class="keyword">class</span> A&gt;();</span><br><span class="line">        <span class="keyword">auto</span> pB = <span class="built_in">make_shared</span>&lt;<span class="keyword">class</span> B&gt;();</span><br><span class="line"></span><br><span class="line">        pA-&gt;m_spB = pB;</span><br><span class="line">        pB-&gt;m_spA = pA;</span><br><span class="line"></span><br><span class="line">        wp1 = pA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp1 reference number: &quot;</span> &lt;&lt; wp1.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">// 存在内存泄露，打印如下，wp1 reference number:1</span></span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="keyword">class</span> <span class="title class_">C</span>&gt; wp2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pC = <span class="built_in">make_shared</span>&lt;<span class="keyword">class</span> C&gt;();</span><br><span class="line">        <span class="keyword">auto</span> pD = <span class="built_in">make_shared</span>&lt;<span class="keyword">class</span> D&gt;();</span><br><span class="line"></span><br><span class="line">        pC-&gt;m_wpD = pD;</span><br><span class="line">        pD-&gt;m_wpC = pC;</span><br><span class="line"></span><br><span class="line">        wp2 = pC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp2 reference number: &quot;</span> &lt;&lt; wp2.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">// 没有内存泄露，打印如下，wp2 reference number:0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::weak_ptr 用来避免 std::shared_ptr 的循环引用</span></span><br><span class="line">    <span class="built_in">test_loop_ref</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，</span></span><br><span class="line"><span class="comment">// 从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> p1 = std::<span class="built_in">make_shared</span>&lt;std::string&gt;(<span class="string">&quot;pointer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p2 = p;</span><br><span class="line">    <span class="keyword">auto</span> p3 = p2;</span><br><span class="line">    <span class="keyword">auto</span> p4 = p3.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p.use_count:&quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1.use_count:&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2.use_count:&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p3.use_count:&quot;</span> &lt;&lt; p3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    p2.<span class="built_in">reset</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p.use_count:&quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1.use_count:&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2.use_count:&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p3.use_count:&quot;</span> &lt;&lt; p3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2:&quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;  <span class="comment">// error: p2 已 reset</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2:&quot;</span> &lt;&lt; *p2 &lt;&lt; std::endl; <span class="comment">// error: p2 已 reset</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，</span></span><br><span class="line"><span class="comment">// 从而保证代码的安全</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// auto up1 = up; // error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Smart Pointer!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_ptr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID 原则</title>
      <link href="/2022/09/13/C++/SOLID%E5%8E%9F%E5%88%99/"/>
      <url>/2022/09/13/C++/SOLID%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="S-单一职责原则">S: 单一职责原则</h2><h2 id="O-开闭原则">O: 开闭原则</h2><h2 id="L-里氏替换原则">L: 里氏替换原则</h2><h2 id="I-接口隔离原则">I: 接口隔离原则</h2><h2 id="D-依赖倒置原则">D: 依赖倒置原则</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 设计模式：工厂方法(Factory Method)</title>
      <link href="/2022/09/13/C++/C++DesignPatterns/C++DesignPatterns-FactoryMethod/"/>
      <url>/2022/09/13/C++/C++DesignPatterns/C++DesignPatterns-FactoryMethod/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂方法-Factory-Method-2">工厂方法(Factory Method)</h2><p>工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p><h3 id="问题">问题</h3><p>在面向对象系统设计中经常可以遇到以下的两类问题：</p><pre><code>1.我们经常会抽象出一些类的公共接口以形成抽象基类或者接口。这样我们可以通过声明一个指向基类的指针来指向实际的子类实现，达到了多态的目的。所以就不得不在要用到子类的地方写new 对象。这样实体类的使用者必须知道实际的子类名称，以及会使程序的扩展性和维护变得越来越困难。2.还有一种情况就是在父类中并不知道具体要实例化哪一个具体的子类。只能在父类中写方法调用，具体调用哪一个类的方法交给子类实现。</code></pre><p>以上两个问题也就引出了 Factory 模式的两个最重要的功能：<br>1）定义创建对象的接口，封装了对象的创建。<br>2）使得具体化类的工作延迟到了子类中。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 设计模式</title>
      <link href="/2022/09/13/C++/C++DesignPatterns/C++DesignPatterns/"/>
      <url>/2022/09/13/C++/C++DesignPatterns/C++DesignPatterns/</url>
      
        <content type="html"><![CDATA[<h2 id="创建型模式">创建型模式</h2><p>创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。</p><h3 id="工厂方法-Factory-Method">工厂方法(Factory Method)</h3><p>工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p><!-- <a href="#">Post not found: _posts-subpath/文章文件名（不要后缀） 文章标题（可选）</a> --><ul><li><a href="/2022/09/13/C++/C++DesignPatterns/C++DesignPatterns-FactoryMethod/" title="C++ 设计模式：工厂方法(Factory Method)">C++ 设计模式：工厂方法(Factory Method)</a></li></ul><h3 id="抽象工厂-Abstract-Factory">抽象工厂(Abstract Factory)</h3><p>抽象工厂是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="生成器-Builder">生成器(Builder)</h3><p>生成器是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="原型-Prototype">原型(Prototype)</h3><p>原型是一种创建型设计模式，使你能够复制已有对象，而无需使代码以来它们所属的类。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="单例-Singleton">单例(Singleton)</h3><p>单例是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h2 id="结构型模式">结构型模式</h2><p>结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。</p><h3 id="适配器-Adapter">适配器(Adapter)</h3><p>适配器是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="桥接-Bridge">桥接(Bridge)</h3><p>适配器是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="组合-Composite">组合(Composite)</h3><p>适配器是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="装饰-Decorator">装饰(Decorator)</h3><p>适配器是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="外观-Facade">外观(Facade)</h3><p>适配器是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="享元-Flyweight">享元(Flyweight)</h3><p>适配器是一种结构型设计模式，它摒弃了每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="代理-Proxy">代理(Proxy)</h3><p>适配器是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h2 id="行为模式">行为模式</h2><p>行为模式负责对象间的高效沟通和职责委派。</p><h3 id="责任链-Chain-Of-Responsibility">责任链(Chain Of Responsibility)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="命令-Command">命令(Command)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="迭代器-Iterator">迭代器(Iterator)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="中介者-Mediator">中介者(Mediator)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="备忘录-Memmento">备忘录(Memmento)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="观察者-Observer">观察者(Observer)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="状态-State">状态(State)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="策略-Strategy">策略(Strategy)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="模板方法-Template-Method">模板方法(Template Method)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h3 id="访问者-Visitor">访问者(Visitor)</h3><p>责任链是一种行为设计模式，</p><ul><li><a href="#">Post not found: C++/C++DesignPatterns/</a></li></ul><h2 id="总结-2">总结</h2><p>在日常开发中常用的设计：</p><ul><li>抽象工厂</li><li>适配器</li><li>生成器</li><li>工厂方法</li><li>单例</li><li>命令</li><li>迭代器</li><li>观察者</li><li>策略</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：thread-local storage（线程局部存储）</title>
      <link href="/2022/09/11/C++/C++Feature/1.28.C++11-thread_local_storage/"/>
      <url>/2022/09/11/C++/C++Feature/1.28.C++11-thread_local_storage/</url>
      
        <content type="html"><![CDATA[<h2 id="存储期">存储期</h2><p>程序中的所有对象都具有下列存储期之一：</p><p>自动（automatic）存储期。这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。<br>静态（static）存储期。这类对象的存储在程序开始时分配，并在程序结束时解分配。这类对象只存在一个实例。所有在命名空间（包含全局命名空间）作用域声明的对象，加上声明带有 static 或 extern 的对象均拥有此存储期。有关拥有此存储期的对象的初始化的细节，见非局部变量与静态局部变量。<br>线程（thread）存储期。这类对象的存储在线程开始时分配，并在线程结束时解分配。每个线程拥有它自身的对象实例。只有声明为 thread_local 的对象拥有此存储期。thread_local 能与 static 或 extern 一同出现，它们用于调整链接。关于具有此存储期的对象的初始化的细节，见非局部变量和静态局部变量。<br>动态（dynamic）存储期。这类对象的存储是通过使用动态内存分配函数来按请求进行分配和解分配的。<br>子对象和引用成员的存储期与它们的完整对象一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">int</span> rage = <span class="number">1</span>; </span><br><span class="line">std::mutex cout_mutex;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase_rage</span><span class="params">(<span class="type">const</span> std::string&amp; thread_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++rage; <span class="comment">// 在锁外修改 OK；这是线程局部变量</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; thread_name &lt;&lt; <span class="string">&quot; 的愤怒计数：&quot;</span> &lt;&lt; rage &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(increase_rage, <span class="string">&quot;a&quot;</span>)</span>, <span class="title">b</span><span class="params">(increase_rage, <span class="string">&quot;b&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;main 的愤怒计数：&quot;</span> &lt;&lt; rage &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">可能的输出：</span><br><span class="line"></span><br><span class="line">a 的愤怒计数：<span class="number">2</span></span><br><span class="line">main 的愤怒计数：<span class="number">1</span></span><br><span class="line">b 的愤怒计数：<span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：GC interface (removed in C++23)（GC 接口）</title>
      <link href="/2022/09/11/C++/C++Feature/1.29.C++11-gc_interface/"/>
      <url>/2022/09/11/C++/C++Feature/1.29.C++11-gc_interface/</url>
      
        <content type="html"><![CDATA[<p>GC interface (removed in C++23)</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：range-for</title>
      <link href="/2022/09/11/C++/C++Feature/1.30.C++11-range-for/"/>
      <url>/2022/09/11/C++/C++Feature/1.30.C++11-range-for/</url>
      
        <content type="html"><![CDATA[<h2 id="基于范围的-for-循环">基于范围的 for 循环</h2><p>在一个范围上执行 for 循环。</p><p>用作对范围中的各个值（如容器中的所有元素）进行操作的传统 for 循环的更加可读的等价版本。</p><p>语法<br>属性(可选) for ( 初始化语句(可选)范围变量声明 : 范围表达式 ) 循环语句</p><p>注意，所有 初始化语句 必然以分号 ; 结尾，因此它经常被非正式地描述为后随分号的表达式或声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; i : v) <span class="comment">// 以 const 引用访问</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="comment">// 以值访问，i 的类型是 int</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : v) <span class="comment">// 以转发引用访问，i 的类型是 int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; cv = v;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : cv) <span class="comment">// 以转发引用访问，i 的类型是 const int&amp;</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) <span class="comment">// 初始化器可以是花括号初始化器列表</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : a) <span class="comment">// 初始化器可以是数组</span></span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> ([[maybe_unused]] <span class="type">int</span> n : a)  </span><br><span class="line">        std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 不必使用循环变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n = v.<span class="built_in">size</span>(); <span class="keyword">auto</span> i : v) <span class="comment">// 初始化语句（C++20）</span></span><br><span class="line">        std::cout &lt;&lt; --n + i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typedef</span> <span class="keyword">decltype</span>(v)::value_type <span class="type">elem_t</span>; <span class="type">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// typedef 声明作为初始化语句（C++20）</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">using</span> <span class="type">elem_t</span> = <span class="keyword">decltype</span>(v)::value_type; <span class="type">elem_t</span> i : v)</span><br><span class="line">    <span class="comment">// 别名声明作为初始化语句，同上（C++23）</span></span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：static_assert</title>
      <link href="/2022/09/11/C++/C++Feature/1.31.C++11-static_assert/"/>
      <url>/2022/09/11/C++/C++Feature/1.31.C++11-static_assert/</url>
      
        <content type="html"><![CDATA[<p>进行编译时断言检查。</p><p>语法<br>static_assert ( 布尔常量表达式 , 消息 )</p><p>如果 布尔常量表达式 返回 true，那么该声明没有效果。否则将发布编译时错误，且当存在 消息时诊断消息中会包含其文本。</p><p>消息 可以省略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_copy_constructible&lt;T&gt;::value,</span><br><span class="line">                  <span class="string">&quot;交换需要可复制&quot;</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_nothrow_copy_constructible&lt;T&gt;::value</span><br><span class="line">               &amp;&amp; std::is_nothrow_copy_assignable&lt;T&gt;::value,</span><br><span class="line">                  <span class="string">&quot;交换需要可复制及可赋值，且无异常抛出&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> c = b;</span><br><span class="line">    b = a;</span><br><span class="line">    a = c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data_structure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_default_constructible&lt;T&gt;::value,</span><br><span class="line">                  <span class="string">&quot;数据结构要求元素可默认构造&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">no_copy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">no_copy</span> ( <span class="type">const</span> no_copy&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">no_copy</span> () = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">no_default</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">no_default</span> () = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line"> </span><br><span class="line">    no_copy nc_a, nc_b;</span><br><span class="line">    <span class="built_in">swap</span>(nc_a, nc_b); <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">    data_structure&lt;<span class="type">int</span>&gt; ds_ok;</span><br><span class="line">    data_structure&lt;no_default&gt; ds_error; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">可能的输出：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>：错误：静态断言失败：交换需要可复制</span><br><span class="line"><span class="number">2</span>：错误：静态断言失败：数据结构要求元素可默认构造</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：multithreaded memory model (多线程内存模型)</title>
      <link href="/2022/09/11/C++/C++Feature/1.27.C++11-multithreaded_memory_model/"/>
      <url>/2022/09/11/C++/C++Feature/1.27.C++11-multithreaded_memory_model/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程内存模型">多线程内存模型</h2><p>为 C++ 抽象机的目的定义了计算机内存存储的语义。</p><p>可为 C++ 程序所用的内存是一或多个字节的连续序列。内存中的每个字节拥有唯一的地址。</p><p>字节（byte）是最小的可寻址内存单元。它被定义为相接的位序列，其大到足以保有任何 UTF-8 编码单元（256 个相异值）<br>与 C 相似，C++ 也支持 8 位或更大的字节。</p><p>char、unsigned char 和 signed char 类型把一个字节用于存储和值表示。字节中的位数可作为 CHAR_BIT 或 std::numeric_limits<unsigned char>::digits 访问。</p><p>内存位置<br>一个内存位置是</p><p>一个标量类型（算术类型、指针类型、枚举类型或 std::nullptr_t）对象<br>或非零长位域的最大相接序列<br>注意：语言的各种功能特性，例如引用和虚函数，可能涉及到程序不可访问，但为实现所管理的额外内存位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">// 内存位置 #1</span></span><br><span class="line">    <span class="type">int</span> b : <span class="number">5</span>;  <span class="comment">// 内存位置 #2</span></span><br><span class="line">    <span class="type">int</span> c : <span class="number">11</span>, <span class="comment">// 内存位置 #2 （延续）</span></span><br><span class="line">          : <span class="number">0</span>,</span><br><span class="line">        d : <span class="number">8</span>;  <span class="comment">// 内存位置 #3</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">int</span> ee : <span class="number">8</span>; <span class="comment">// 内存位置 #4</span></span><br><span class="line">    &#125; e;</span><br><span class="line">&#125; obj; <span class="comment">// 对象 &#x27;obj&#x27; 由 4 个分离的内存位置组成</span></span><br></pre></td></tr></table></figure><p>线程与数据竞争<br>执行线程是程序中的控制流，它始于 std::thread::thread、std::async 或以其他方式所进行的顶层函数调用。</p><p>任何线程都能潜在地访问程序中的任何对象（拥有自动或线程局部存储期的对象仍然可以被另一线程通过指针或引用访问）。</p><p>不同的执行线程始终可以同时访问（读和写）不同的内存位置，不需要干涉或同步的任何要求。</p><p>当某个表达式的求值写入某个内存位置，而另一求值读或修改同一内存位置时，称这些表达式冲突。拥有两个冲突的求值的程序就有数据竞争，除非</p><p>两个求值都在同一线程上，或者在同一信号处理函数中执行，或<br>两个冲突的求值都是原子操作（见 std::atomic ），或<br>一个冲突的求值发生早于（happens-before）另一个（见 std::memory_order）<br>若出现数据竞争，则程序的行为未定义。</p><p>（特别是，std::mutex 的释放同步于，从而发生早于另一线程对同一 mutex 的获取，这使得互斥锁可以用来防止数据竞争）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123;cnt++;&#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;; <span class="comment">// 未定义行为</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;]&#123;cnt++;&#125;;</span><br><span class="line">std::thread t1&#123;f&#125;, t2&#123;f&#125;, t3&#123;f&#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>内存顺序<br>当线程从某个内存位置读取值时，它可能看到初值，同一线程所写入的值，或另一线程所写入的值。有关线程所作的写入操作对其他线程变为可见的顺序上的细节，见 std::memory_order。</p><p>向前进展<br>免妨碍<br>当只有一个未在标准库函数中阻塞的线程执行某个免锁的原子函数时，保证该执行将会完成（所有标准库免锁操作均为免妨碍的）。</p><p>免锁<br>当一或多个免锁原子函数同时运行时，保证其中至少一个将会完成（所有标准库免锁操作均为免锁的——确保其他线程不能不确定地活锁它们（例如以连续窃取缓存线的方式），是实现的工作）。</p><p>进展保证<br>合法的 C++ 程序中，每个线程最终要做下列之一：</p><p>终止<br>调用 I/O 库函数<br>通过 volatile 泛左值进行访问<br>进行原子操作或同步操作<br>没有线程能在不做任何这些可观察行为的情况下永远执行。</p><p>注意，这意味着包含无限递归或无限循环（无论是实现为 for 语句 或是用 goto 循环还是其他方式）的程序具有未定义行为。这允许编译器移除所有无可观察行为的循环，而不必证明他们终将终止。</p><p>若线程执行了上述步骤之一（I/O、volatile、原子或同步操作），阻塞于标准库函数中，或调用由于某个未阻塞的并发线程而未能完成的原子免锁函数，则称它取得进展（make progress）。</p><p>并发向前进展<br>若线程提供并发向前进展保证（concurrent forward progress guarantee），则只要它尚未终止，就将在有限量的时间内取得进展（定义如上），无关乎其他线程（若存在）是否取得进展。</p><p>标准鼓励但不要求主线程和 std::thread 所启动的线程提供并发向前进展保证。</p><p>并行向前进展<br>若线程提供并行向前进展保证（parallel forward progress guarantee），则若线程尚未执行任何执行步骤（I/O、volatile、原子或同步操作），就不要求实现保证该线程终将取得进展，但一旦此线程开始执行步骤，则它提供并发向前进展保证（此规则描述线程池中以任意顺序执行任务的线程）。</p><p>弱并行向前进展<br>若线程提供弱并行向前进展保证（weakly parallel forward progress guarantee），则不保证它终将取得进展，无关乎其他线程是否取得进展。</p><p>此类线程仍然能通过以向前进展保证委托进行阻塞来保证取得进展：若线程 P 以此方式阻塞于线程集合 S 的完成，则 S 中至少有一个线程将提供等于或强于 P 的向前进展保证。一旦该线程完成，则类似地强化 S 中的另一线程。一旦该集合为空，则解除 P 的阻塞。</p><p>来自 C++ 标准库的并行算法，均以向前保证委托阻塞于某个标准库所管理的线程的未指明集合的完成上。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：alignof 与 alignas</title>
      <link href="/2022/09/11/C++/C++Feature/1.26.C++11-alignof_and_alignas/"/>
      <url>/2022/09/11/C++/C++Feature/1.26.C++11-alignof_and_alignas/</url>
      
        <content type="html"><![CDATA[<h2 id="alignof-运算符">alignof 运算符</h2><p>查询类型的对齐要求。</p><p>语法<br>alignof( 类型标识 )<br>返回 std::size_t 类型的值。</p><p>返回由类型标识所指示的类型的任何实例所要求的对齐字节数，该类型可以是完整对象类型、元素类型完整的数组类型或者到这些类型之一的引用类型。</p><p>如果类型是引用类型，那么运算符返回被引用类型的对齐要求；如果类型是数组类型，那么返回元素类型的对齐要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>   i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span>  c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 注：下面的 `alignas(alignof(long double))`</span></span><br><span class="line"><span class="comment">// 如果需要可以简化为  `alignas(long double)`</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">long</span> <span class="type">double</span>)) Foo2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Foo2 成员的定义...</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) Empty64 &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对齐字节数&quot;</span>  <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- char                ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">char</span>)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- 指针                ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">int</span>*)     &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- Foo 类              ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo)      &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- Foo2 类             ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Foo2)     &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- 空类                ：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty)    &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;- 带 alignas(64) 的空类：&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty64) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">可能的输出：</span><br><span class="line"></span><br><span class="line">对齐字节数</span><br><span class="line">- <span class="type">char</span>                ：<span class="number">1</span></span><br><span class="line">- 指针                ：<span class="number">8</span></span><br><span class="line">- Foo 类              ：<span class="number">4</span></span><br><span class="line">- Foo2 类             ：<span class="number">16</span></span><br><span class="line">- 空类                ：<span class="number">1</span></span><br><span class="line">- 带 <span class="built_in">alignas</span>(<span class="number">64</span>) 的空类：<span class="number">64</span></span><br></pre></td></tr></table></figure><h2 id="alignas-说明符">alignas 说明符</h2><p>指定类型或对象的对齐要求。</p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>alignas( 表达式 )</td><td>表达式 必须是求值为零或合法的对齐或扩展对齐的整型常量表达式。</td></tr><tr><td>alignas( 类型标识 )</td><td>等价于 alignas(alignof(类型标识))</td></tr><tr><td>alignas( 包 … )</td><td>等价于对同一说明应用多个 alignas 说明符，逐个对应于形参包的各个成员，形参包可以是类型或非类型形参包。</td></tr></tbody></table><p>alignas 说明符可用于：</p><ul><li>类的声明或定义；</li><li>非位域类数据成员的声明；</li><li>变量声明，除了它不能应用于下列内容：<ul><li>函数形参；</li><li>catch 子句的异常形参。</li></ul></li></ul><p>这种声明所声明的对象或类型的对齐要求将等于用于该声明的所有 alignas 说明符中最严格（最大）的非零 表达式，除非这会削弱类型的自然对齐。</p><p>如果某个声明上的最严格（最大）alignas 比当它没有任何 alignas 说明符的情况下本应有的对齐更弱（即弱于其原生对齐，或弱于同一对象或类型的另一声明上的 alignas），那么程序非良构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) S &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">1</span>) U &#123; S s; &#125;; <span class="comment">// 错误：如果没有 alignas(1) 那么 U 的对齐将会是 8</span></span><br></pre></td></tr></table></figure><p>无效的非零对齐，例如 alignas(3) 非良构。</p><p>同一声明上，比其他 alignas 弱的有效的非零对齐被忽略。</p><p>始终忽略 alignas(0)。</p><p>按 ISO C11 标准，C 语言有 _Alignas 关键词，并于头文件 &lt;stdalign.h&gt; 中将 alignas 定义为展开成该关键词的预处理器宏。</p><p>在 C++ 中这是关键词，且</p><p>头文件 &lt;stdalign.h&gt; 与 <cstdalign> 并不定义这个宏。不过它们仍定义宏常量 __alignas_is_defined。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个 struct_float 类型对象都将被对齐到 alignof(float) 边界</span></span><br><span class="line"><span class="comment">// （通常为 4）：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="built_in">alignof</span>(<span class="type">float</span>)) struct_float</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义在此</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// sse_t 类型的每个对象将对齐到 32 字节边界</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) <span class="type">sse_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sse_data[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 数组 &quot;cacheline&quot; 将对齐到 64 字节边界</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">64</span>) <span class="type">char</span> cacheline[<span class="number">64</span>];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">default_aligned</span> &#123; <span class="type">float</span> data[<span class="number">4</span>]; &#125; a, b, c;</span><br><span class="line">    <span class="type">sse_t</span> x, y, z;</span><br><span class="line"> </span><br><span class="line">    std::cout</span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(struct_float) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(struct_float) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;sizeof(sse_t) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">sse_t</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(sse_t) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="type">sse_t</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;alignof(cacheline) = &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(<span class="built_in">alignas</span>(<span class="number">64</span>) <span class="type">char</span>[<span class="number">64</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; std::hex &lt;&lt; std::showbase</span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;b: &quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;c: &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;x: &quot;</span> &lt;&lt; &amp;x &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;y: &quot;</span> &lt;&lt; &amp;y &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;&amp;z: &quot;</span> &lt;&lt; &amp;z &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">可能的输出：</span><br><span class="line"></span><br><span class="line"><span class="built_in">alignof</span>(struct_float) = <span class="number">4</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">sse_t</span>) = <span class="number">32</span></span><br><span class="line"><span class="built_in">alignof</span>(<span class="type">sse_t</span>) = <span class="number">32</span></span><br><span class="line"><span class="built_in">alignof</span>(cacheline) = <span class="number">64</span></span><br><span class="line">&amp;a: <span class="number">0x7fffcec89930</span></span><br><span class="line">&amp;b: <span class="number">0x7fffcec89940</span></span><br><span class="line">&amp;c: <span class="number">0x7fffcec89950</span></span><br><span class="line">&amp;x: <span class="number">0x7fffcec89960</span></span><br><span class="line">&amp;y: <span class="number">0x7fffcec89980</span></span><br><span class="line">&amp;z: <span class="number">0x7fffcec899a0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：noexcept</title>
      <link href="/2022/09/11/C++/C++Feature/1.25.C++11-noexcept/"/>
      <url>/2022/09/11/C++/C++Feature/1.25.C++11-noexcept/</url>
      
        <content type="html"><![CDATA[<h2 id="noexcept">noexcept</h2><h2 id="noexcept-说明符">noexcept 说明符</h2><p>指定函数是否抛出异常。</p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>noexcept</td><td>与 noexcept(true) 相同</td></tr><tr><td>noexcept(表达式)</td><td>如果 表达式 求值为 true，那么声明函数不会抛出任何异常。后随 noexcept 的 ( 只能是该形式的一部分（它不是初始化器的开始）。</td></tr></tbody></table><p>noexcept 说明不是函数类型的一部分（正如同动态异常说明），而且只能在声明函数、变量、函数类型的非静态数据成员、函数指针、函数引用或成员函数指针时，以及在以上这些声明中声明类型为函数指针或函数引用的形参或返回类型时，作为 lambda 声明符或顶层函数声明符的一部分出现。它不能在 typedef 或类型别名声明中出现。</p><p>C++ 中的每个函数要么不会抛出，要么有可能会抛出。<br>有可能会抛出的函数是：</p><ul><li>声明带有求值为 false 的 表达式 的 noexcept 说明符的函数</li><li>声明不带有 noexcept 声明的函数，除了<ul><li>析构函数，除非有任何可能在构造的基类或成员的析构函数有可能会抛出</li><li>隐式声明的或在它的首个声明被预置的默认构造函数、复制构造函数、移动构造函数，除非<ul><li>由构造函数的隐式定义所调用的某个基类或成员的构造函数有可能会抛出</li><li>这种初始化的某个子表达式，例如默认实参表达式，有可能会抛出</li><li>（默认构造函数的）默认成员初始化器有可能会抛出</li></ul></li><li>隐式声明的或在它的首个声明被预置的复制赋值运算符、移动赋值运算符，除非隐式定义中对任何赋值运算符的调用有可能会抛出</li><li>解分配函数</li></ul></li><li>所有其他函数（以求值为 true 的 表达式 的 noexcept 说明符声明的函数，以及析构函数、预置的特殊成员函数和解分配函数）都不会抛出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 错误：异常说明不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>; <span class="comment">// OK：g 的两个声明均有可能会抛出</span></span><br></pre></td></tr></table></figure><p>如果虚函数不会抛出，那么它每个覆盖的函数的所有声明（包括定义）都必须不抛出，除非覆盖函数被定义为弃置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;          <span class="comment">// 谬构：D::f 有可能会抛出，B::f 不会抛出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>= <span class="keyword">delete</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="noexcept-运算符">noexcept 运算符</h2><p>noexcept 运算符进行编译时检查，如果表达式不会抛出任何异常则返回 true。</p><p>它可用于函数模板的 noexcept 说明符中，以声明函数将对某些类型抛出异常，但不对其他类型抛出。</p><p>语法<br>noexcept( 表达式 )<br>返回 bool 类型的纯右值。</p><p>解释<br>noexcept 运算符不会对 表达式 求值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_throw</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">auto</span> lmay_throw = []&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> lno_throw = []() <span class="keyword">noexcept</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">T</span>()&#123;&#125; <span class="comment">// 析构函数妨碍了移动构造函数</span></span><br><span class="line">           <span class="comment">// 复制构造函数不会抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">U</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">U</span>()&#123;&#125; <span class="comment">// 析构函数妨碍了移动构造函数</span></span><br><span class="line">           <span class="comment">// 复制构造函数可能会抛出异常</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    U u;</span><br><span class="line">    V v;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; std::boolalpha</span><br><span class="line">        &lt;&lt; <span class="string">&quot;may_throw() 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">may_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;no_throw() 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">no_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;lmay_throw() 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">lmay_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;lno_throw() 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">lno_throw</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;~T() 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(std::<span class="built_in">declval</span>&lt;T&gt;().~<span class="built_in">T</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        <span class="comment">// 注：以下各项测试也要求 ~T() 不会抛出异常</span></span><br><span class="line">        <span class="comment">// 因为 noexcept 中的表达式会构造并销毁临时量</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;T(T 右值) 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">T</span>(std::<span class="built_in">declval</span>&lt;T&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;T(T 左值) 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">T</span>(t)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;U(U 右值) 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">U</span>(std::<span class="built_in">declval</span>&lt;U&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;U(U 左值) 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">U</span>(u)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>  </span><br><span class="line">        &lt;&lt; <span class="string">&quot;V(V 右值) 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">V</span>(std::<span class="built_in">declval</span>&lt;V&gt;())) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;V(V 左值) 可能会抛出异常吗？&quot;</span> &lt;&lt; !<span class="built_in">noexcept</span>(<span class="built_in">V</span>(v)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="built_in">may_throw</span>() 可能会抛出异常吗？<span class="function"><span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">no_throw</span><span class="params">()</span> 可能会抛出异常吗？<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="title">lmay_throw</span><span class="params">()</span> 可能会抛出异常吗？<span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">lno_throw</span><span class="params">()</span> 可能会抛出异常吗？<span class="literal">false</span></span></span><br><span class="line"><span class="function">~<span class="title">T</span><span class="params">()</span> 可能会抛出异常吗？<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(T 右值)</span> 可能会抛出异常吗？<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(T 左值)</span> 可能会抛出异常吗？<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="title">U</span><span class="params">(U 右值)</span> 可能会抛出异常吗？<span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">U</span><span class="params">(U 左值)</span> 可能会抛出异常吗？<span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">V</span><span class="params">(V 右值)</span> 可能会抛出异常吗？<span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="title">V</span><span class="params">(V 左值)</span> 可能会抛出异常吗？<span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>noexcept 修饰符有两种形式：</p><ul><li>一种就是简单地在函数声明后加上 noexcept 关键字，表示其修饰的函数不会抛出异常。 比如： <code>void excpt_func() noexcept;</code></li><li>另外一种则可以接受一个常量表达式作为参数： <code>void excpt_func() noexcept ( 常量表达式 );</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Throw</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NoBlockThrow</span><span class="params">()</span> </span>&#123; <span class="built_in">Throw</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 C++11 中使用 noexcept 可以有效地阻止异常的传播与扩散</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockThrow</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">Throw</span>(); &#125; <span class="comment">// 会直接调用 std::terminate 中断程序的执行，从而阻止了异常的继续传播</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 还不知道怎么用</span></span><br><span class="line"><span class="comment">// fun函数是否是一个noexcept的函数，将由T()表达式是否会抛出异常所决定。</span></span><br><span class="line"><span class="comment">// 这里的第二个noexcept就是一个noexcept操作符。当其参数是一个有可能抛出异常的表达式的时候，其返回值为false，反之为true</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(T()))</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// C++11默认将delete函数设置成noexcept，就可以提高应用程序的安全性</span></span><br><span class="line">    <span class="comment">// ~A() noexcept(false) &#123; throw 1; &#125;</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;  <span class="comment">// 崩溃</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    ~<span class="built_in">B</span>() <span class="built_in">noexcept</span>(<span class="literal">false</span>) &#123; <span class="keyword">throw</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123; A a; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcC</span><span class="params">()</span> </span>&#123; C c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define run1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> run2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> run1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">Throw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found throw.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NoBlockThrow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Throw is not blocked.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">BlockThrow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found throw 1.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(run2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">funcB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;caught funcB.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">funcC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;caught funcC.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">funcA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;caught funcA.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：lambda expressions（lambda 表达式）</title>
      <link href="/2022/08/30/C++/C++Feature/1.24.C++11-lambda_expressions/"/>
      <url>/2022/08/30/C++/C++Feature/1.24.C++11-lambda_expressions/</url>
      
        <content type="html"><![CDATA[<h2 id="lambda-expressions（lambda-表达式）">lambda expressions（lambda 表达式）</h2><p>语法：<br><a href="parameters">capture</a>mutable-&gt;return-type{ statement; };</p><p>[capture]     捕获列表。<br>[parameters]  参数列表。<br>-&gt;return-type 返回类型。<br>{statement}   函数体。</p><p>语法上，捕获列表由多个捕获项组成，并以逗号分割，形式如下（值传递和引用传递）：<br>1.[var]  表示值传递方式捕获变量var<br>2.[=]    表示值传递方式捕获所有父作用域的变量（包括this）<br>3.[&amp;var] 表示引用传递捕获变量var<br>4.[&amp;]    表示引用传递不会所有父作用域的变量（包括this）<br>5.[this] 表示值传递方式捕获当前的this指针<br>父作用域：指的是包含lambda函数的语句块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">auto</span> func = [](<span class="type">int</span> x, <span class="type">int</span> y)-&gt;<span class="type">int</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">     <span class="keyword">auto</span> c = <span class="built_in">func</span>(a, b);</span><br><span class="line">     cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     [] &#123;&#125;; <span class="comment">// 最简 lambda 函数</span></span><br><span class="line">     [=] &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// 省略了参数列表和返回类型</span></span><br><span class="line">     <span class="keyword">auto</span> func1 = [&amp;](<span class="type">int</span> c) &#123; b = a + c; &#125;; <span class="comment">// 省略了返回类型</span></span><br><span class="line">     <span class="keyword">auto</span> func2 = [=, &amp;b](<span class="type">int</span> c)-&gt;<span class="type">int</span> &#123; <span class="keyword">return</span> b += a + c; &#125;;</span><br><span class="line">     <span class="keyword">auto</span> func3 = [a, &amp;b]()-&gt;<span class="type">int</span> &#123; <span class="keyword">return</span> b += a; &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：user-defined literals（用户定义字面量）</title>
      <link href="/2022/08/30/C++/C++Feature/1.22.C++11-user-defined_literals/"/>
      <url>/2022/08/30/C++/C++Feature/1.22.C++11-user-defined_literals/</url>
      
        <content type="html"><![CDATA[<h2 id="user-defined-literals（用户定义字面量）">user-defined literals（用户定义字面量）</h2><p>通过定义用户定义的后缀，允许整数、浮点数、字符及字符串字面量产生用户定义类型的对象。</p><p>1-4) 用户定义整数字面量，例如 12_km<br>5-6) 用户定义浮点字面量，例如 0.5_Pa<br>7) 用户定义字符字面量，例如 ‘c’_X<br>8) 用户定义字符串字面量，例如 “abd”_L 或 u&quot;xyz&quot;_M<br>十进制字面量 - 与整数字面量中相同，非零的十进制数位后随零或多个十进制数位<br>八进制字面量 - 与整数字面量中相同，零后随零或多个八进制数位<br>十六进制字面量 - 与整数字面量中相同，0x 或 0X 后随一个或多个十六进制数位<br>二进制字面量 - 与整数字面量中相同，0b 或 0B 后随一或多个二进制数位<br>数字序列 - 与浮点字面量中相同，一个十进制数字序列<br>分数常量 - 与浮点字面量中相同，要么是一个后随小数点的 数字序列（123.），要么是一个可选的 数字序列 后随小数点和另一个 数字序列（1.0 或 .12）<br>指数部分 - 与浮点字面量中相同，字母 e 或字母 E 后随可选的正负号，后随 数字序列<br>字符字面量 - 与字符字面量中相同<br>字符串字面量 - 与字符串字面量中相同，包括原始字符串字面量<br>用户定义后缀 - 标识符，由字面量运算符或字面量运算符模板声明引入（见下文）。所有程序引入的 用户定义后缀 必须以下划线字符<code>_</code>开始。标准库的 用户定义后缀 不以下划线开始。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：attributes（属性）</title>
      <link href="/2022/08/30/C++/C++Feature/1.23.C++11-attributes/"/>
      <url>/2022/08/30/C++/C++Feature/1.23.C++11-attributes/</url>
      
        <content type="html"><![CDATA[<h2 id="attributes（属性）">attributes（属性）</h2><p>属性说明符序列(C++11 起)</p><p>为类型、对象、代码等引入由实现定义的属性。</p><p><code>[[属性]] [[属性1, 属性2, 属性3(实参)]] [[命名空间::属性(实参)]] alignas说明符</code></p><p>正式而言，语法是 <code>[[ 属性列表 ]]</code></p><p>其中 属性列表 是由逗号分隔的零或更多个 属性 的序列（可以以指示包展开的省略号 … 结束）<br>标识符<br>属性命名空间 :: 标识符<br>标识符 (实参列表)<br>属性命名空间 :: 标识符 (实参列表)</p><ol><li>简单属性，例如 <code>[[noreturn]]</code></li><li>有命名空间的属性，例如 <code>[[gnu::unused]]</code></li><li>有实参的属性，例如 <code>[[deprecated(&quot;because&quot;)]]</code></li><li>既有命名空间又有实参列表的属性</li></ol><p>属性为各种由实现定义的语言扩展（例如 GNU 与 IBM 的语言扩展 <code>__attribute__((...))</code>，微软的语言扩展 <code>__declspec()</code> 等）提供了统一化的语法。</p><p>属性可用在 C++ 程序中的几乎所有位置，而且可应用于几乎所有事物：类型、变量、函数、名字、代码块、整个翻译单元，不过每个特定的属性都只在实现允许范围内有效：<code>[[expect_true]]</code> 可能是只能与 <code>if</code>，而非与类声明一同使用的属性，<code>[[omp::parallel()]]</code> 可能是应用到代码块或 <code>for</code> 循环，而非到类型 <code>int</code> 等的属性。（请注意以上两个属性只是虚构的例子，有关标准与一些非标准属性请见下文）</p><p>在声明中，属性既可以在整个声明之前出现，也可以直接跟在被声明实体的名字之后，这些情况下它们被组合起来。大多数其他情形中，属性应用于直接位于其之前的实体。</p><p>虽然 <code>alignas</code> 说明符拥有不同的语法，但它是属性序列说明符的一部分。它可以在 … 属性出现的地方出现，并可以和它们混合（假设此处允许使用 alignas）</p><p>两个连续的方括号记号（<code>[[</code>）只能在引入属性说明符的地方出现，或在属性实参之内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">3</span>];</span><br><span class="line">    y[[] &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;()] = <span class="number">1</span>; <span class="comment">// 错误</span></span><br><span class="line">    <span class="type">int</span> i [[cats::<span class="built_in">meow</span>([[]])]]; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了以下所列出的标准属性之外，实现还可能支持任意拥有由实现定义的行为的非标准属性。所有实现所未知的属性均被忽略，且不产生错误。 (C++17 起)</p><p>无 属性命名空间 的属性与名字以 std 或 std 后随一或多个数字的 属性命名空间 为未来标准化保留。即每个非标准属性都在实现提供的 属性命名空间 中，例如 [[gnu::may_alias]]、 [[clang::trivial_abi]] 和 [[msvc::noop_dtor]]。(C++20 起)<br>标准属性</p><p>C++ 标准仅定义下列属性。<br>[[noreturn]](C++11 起)  指示函数不返回<br>[[carries_dependency]](C++11 起)  指示释放消费 std::memory_order 中的依赖链传入和传出该函数。<br>[[deprecated]](C++14 起)<br>[[deprecated(“原因”)]](C++14 起)  指示允许使用声明有此属性的名称或实体，但因 原因 而不鼓励使用。<br>[[fallthrough]](C++17 起)  指示从前一 case 标号直落是有意的，而在发生直落时给出警告的编译器不应该为此诊断。<br>[[nodiscard]](C++17 起)<br>[[nodiscard(“原因”)]](C++20 起)  鼓励编译器在返回值被舍弃时发布警告。<br>[[maybe_unused]](C++17 起)  压制编译器在未使用实体上的警告，若存在。<br>[[likely]](C++20 起)<br>[[unlikely]](C++20 起)  指示编译器应该针对通过某语句的执行路径比任何其他执行路径更可能或更不可能的情况进行优化。<br>[[no_unique_address]](C++20 起)  指示非静态数据成员不需要拥有不同于其类的所有其他非静态数据成员的地址。<br>[[optimize_for_synchronized]](TM TS)  指示应该针对来自 synchronized 语句的调用来优化该函数定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">[[gnu::always_inline]] [[gnu::hot]] [[gnu::<span class="type">const</span>]] [[nodiscard]]</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 声明 f 带四个属性</span></span><br><span class="line"> </span><br><span class="line">[[gnu::always_inline, gnu::<span class="type">const</span>, gnu::hot, nodiscard]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 同上，但使用含有四个属性的单个属性说明符</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++17:</span></span><br><span class="line">[[<span class="keyword">using</span> gnu : <span class="type">const</span>, always_inline, hot]] [[nodiscard]]</span><br><span class="line"><span class="type">int</span> f[[gnu::always_inline]](); <span class="comment">// 属性可出现于多个说明符中</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：unicode string literals（Unicode 字符串字面量）</title>
      <link href="/2022/08/30/C++/C++Feature/1.21.C++11-unicode_string_literals/"/>
      <url>/2022/08/30/C++/C++Feature/1.21.C++11-unicode_string_literals/</url>
      
        <content type="html"><![CDATA[<h2 id="Unicode-字符串字面量">Unicode 字符串字面量</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>“s字符序列(可选)”</td><td>通常字符串字面量。无前缀字符串字面量的类型是 const char[N]，其中 N 是以执行窄编码 (C++23 前)通常字面量编码 (C++23 起)的编码单元计的字符串的大小，包含空终止符。</td></tr><tr><td>L&quot;s字符序列(可选)&quot;</td><td>宽字符串字面量。L&quot;…&quot; 字符串字面量的类型是 const wchar_t[N]，其中 N 是以执行宽编码 (C++23 前)宽字面量编码 (C++23 起)的编码单元计的字符串的大小，包含空终止符。</td></tr><tr><td>u8&quot;s字符序列(可选)&quot;</td><td>UTF-8 字符串字面量。u8&quot;…&quot; 字符串字面量的类型是 const char[N] (C++20 前)const char8_t[N] (C++20 起)，其中 N 是以 UTF-8 编码单元计的字符串的大小，包含空终止符。</td></tr><tr><td>u&quot;s字符序列(可选)&quot;</td><td>UTF-16 字符串字面量。u&quot;…&quot; 字符串字面量的类型是 const char16_t[N]，其中 N 是以 UTF-16 编码单元计的字符串的大小，包含空终止符。</td></tr><tr><td>U&quot;s字符序列(可选)&quot;</td><td>UTF-32 字符串字面量。U&quot;…&quot; 字符串字面量的类型是 const char32_t[N]，其中 N 是以 UTF-32 编码单元计的字符串的大小，包含空终止符。</td></tr><tr><td>前缀(可选) R&quot;d字符序列(可选)(r字符序列(可选))d字符序列(可选)&quot;</td><td>原始字符串字面量。用于避免转义任何字符。分隔符间的任何内容都成为字符串的一部分。如果存在 前缀 则具有与上述相同的含义。结尾的 d字符序列需要和开头的 d字符序列一致。</td></tr></tbody></table><table><thead><tr><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>s字符序列</td><td>一个或多个s字符</td></tr><tr><td>s字符</td><td>下列之一：<br/>一个基础s字符<br/>    一个转义序列，定义见转义序列<br/>    一个通用字符名，定义见转义序列<br/></td></tr><tr><td>基础s字符</td><td>来自源字符集 (C++23 前)翻译字符集 (C++23 起)去掉双引号（&quot;）、反斜杠（\）和换行符后的字符</td></tr><tr><td>前缀</td><td>L、u8、u、U 之一</td></tr><tr><td>d字符序列</td><td>一个或多个d字符，最多十六个</td></tr><tr><td>d字符</td><td>来自基础源字符集 (C++23 前)基础字符集 (C++23 起)去掉括号、反斜杠和空格后的字符</td></tr><tr><td>r字符序列</td><td>一个或多个r字符，不得包含闭序列 )d字符序列&quot;</td></tr><tr><td>r字符</td><td>来自源字符集 (C++23 前)翻译字符集 (C++23 起)的字符</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：generalized PODs (trivial types and standard-layout types)（推广的 POD （平凡类型与标准布局类型））</title>
      <link href="/2022/08/30/C++/C++Feature/1.20.C++11-generalized_PODs/"/>
      <url>/2022/08/30/C++/C++Feature/1.20.C++11-generalized_PODs/</url>
      
        <content type="html"><![CDATA[<h2 id="推广的-POD">推广的 POD</h2><p>指定类型为 POD（Plain Old Data，简旧数据）类型。这表示该类型与用于 C 程序语言的类型兼容，即它能直接以二进制形式与 C 库交互。</p><p>注意：标准中并没有定义具有这个名字的具名要求。这是核心语言所定义的一种类型类别。将它作为具名要求包含于此只是为了保持一致性。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：variadic templates（可变参数模板）</title>
      <link href="/2022/08/30/C++/C++Feature/1.18.C++11-variadic_templates/"/>
      <url>/2022/08/30/C++/C++Feature/1.18.C++11-variadic_templates/</url>
      
        <content type="html"><![CDATA[<h2 id="形参包">形参包</h2><p>模板形参包是接受零个或更多个模板实参（非类型、类型或模板）的模板形参。函数形参包是接受零个或更多个函数实参的函数形参。</p><p>至少有一个形参包的模板被称作变参模板。</p><p>变参类模板可以用任意数量的模板实参实例化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tuple</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Tuple&lt;&gt; t0;           <span class="comment">// Types 不包含实参</span></span><br><span class="line">Tuple&lt;<span class="type">int</span>&gt; t1;        <span class="comment">// Types 包含一个实参：int</span></span><br><span class="line">Tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt; t2; <span class="comment">// Types 包含两个实参：int 与 float</span></span><br><span class="line">Tuple&lt;<span class="number">0</span>&gt; error;       <span class="comment">// 错误：0 不是类型</span></span><br></pre></td></tr></table></figure><p>变参函数模板可以用任意数量的函数实参调用（模板实参通过模板实参推导推导）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Types... args)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">f</span>();       <span class="comment">// OK：args 不包含实参</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>);      <span class="comment">// OK：args 包含一个实参：int</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2</span>, <span class="number">1.0</span>); <span class="comment">// OK：args 包含两个实参：int 与 double</span></span><br></pre></td></tr></table></figure><p>在主类模板中，模板形参包必须是模板形参列表的最后一个形参。在函数模板中，模板参数包可以在列表中更早出现，只要其后的所有形参都可以从函数实参推导或拥有默认实参即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span>... Ts&gt;    <span class="comment">// OK：能推导出 U</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">valid</span>;</span><br><span class="line"><span class="comment">// template&lt;typename... Ts, typename U&gt; // 错误：Ts... 不在结尾</span></span><br><span class="line"><span class="comment">// struct Invalid;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> U, <span class="keyword">typename</span></span>=<span class="type">void</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">valid</span><span class="params">(U, Ts...)</span></span>;    <span class="comment">// OK：能推导出 U</span></span><br><span class="line"><span class="comment">// void valid(Ts..., U); // 不能使用：Ts... 在此位置是不推导语境</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">valid</span>(<span class="number">1.0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);     <span class="comment">// OK：推导出 U 是 double，Ts 是 &#123;int, int, int&#125;</span></span><br></pre></td></tr></table></figure><p>如果变参模板的每个合法的特化都要求空模板形参包，那么程序非良构，不要求诊断。<br>包展开</p><p>后随省略号且其中至少有一个形参包的名字至少出现了一次的模式会被展开成零个或更多个逗号分隔的模式实例，其中形参包的名字按顺序被替换成包中的各个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Us&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Us... pargs)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(&amp;args...); <span class="comment">// “&amp;args...” 是包展开</span></span><br><span class="line">                 <span class="comment">// “&amp;args” 是它的模式</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">g</span>(<span class="number">1</span>, <span class="number">0.2</span>, <span class="string">&quot;a&quot;</span>); <span class="comment">// Ts... args 会展开成 int E1, double E2, const char* E3</span></span><br><span class="line">                <span class="comment">// &amp;args... 会展开成 &amp;E1, &amp;E2, &amp;E3</span></span><br><span class="line">                <span class="comment">// Us... 会展开成 int* E1, double* E2, const char** E3</span></span><br></pre></td></tr></table></figure><p>如果两个形参包在同一模式中出现，那么它们同时展开而且长度必须相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tuple</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args1&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">zip</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args2&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">with</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> Tuple&lt;Pair&lt;Args1, Args2&gt;...&gt; type;</span><br><span class="line">        <span class="comment">// Pair&lt;Args1, Args2&gt;... 是包展开</span></span><br><span class="line">        <span class="comment">// Pair&lt;Args1, Args2&gt; 是模式</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> zip&lt;<span class="type">short</span>, <span class="type">int</span>&gt;::with&lt;<span class="type">unsigned</span> <span class="type">short</span>, <span class="type">unsigned</span>&gt;::type T1;</span><br><span class="line"><span class="comment">// Pair&lt;Args1, Args2&gt;... 会展开成</span></span><br><span class="line"><span class="comment">// Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned int&gt; </span></span><br><span class="line"><span class="comment">// T1 是 Tuple&lt;Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned&gt;&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> zip&lt;<span class="type">short</span>&gt;::with&lt;<span class="type">unsigned</span> <span class="type">short</span>, <span class="type">unsigned</span>&gt;::type T2;</span><br><span class="line"><span class="comment">// 错误：包展开中的形参包包含不同长度</span></span><br></pre></td></tr></table></figure><p>如果包展开内嵌于另一个包展开中，那么它所展开的是在最内层包展开出现的形参包，并且在外围（而非最内层）的包展开中必须提及其它形参包：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> Args*&gt;(&amp;args)...); </span><br><span class="line">    <span class="comment">// const_cast&lt;const Args*&gt;(&amp;args) 是模式，它同时展开两个包（Args 与 args）</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">f</span>(<span class="built_in">h</span>(args...) + args...); <span class="comment">// 嵌套包展开：</span></span><br><span class="line">    <span class="comment">// 内层包展开是 “args...”，它首先展开</span></span><br><span class="line">    <span class="comment">// 外层包展开是 h(E1, E2, E3) + args 它其次被展开</span></span><br><span class="line">    <span class="comment">// （成为 h(E1, E2, E3) + E1, h(E1, E2, E3) + E2, h(E1, E2, E3) + E3）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展开场所</p><p>展开所产生的逗号分隔列表按发生展开的各个场所可以是不同种类的列表：函数形参列表，成员初始化器列表，属性列表，等等。以下列出了所有允许的语境。<br>函数实参列表</p><p>包展开可以在函数调用运算符的括号内出现，此时省略号左侧的最大表达式或花括号初始化器列表是被展开的模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(&amp;args...);             <span class="comment">// 展开成 f(&amp;E1, &amp;E2, &amp;E3)</span></span><br><span class="line"><span class="built_in">f</span>(n, ++args...);         <span class="comment">// 展开成 f(n, ++E1, ++E2, ++E3);</span></span><br><span class="line"><span class="built_in">f</span>(++args..., n);         <span class="comment">// 展开成 f(++E1, ++E2, ++E3, n);</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> Args*&gt;(&amp;args)...);</span><br><span class="line"><span class="comment">// f(const_cast&lt;const E1*&gt;(&amp;X1), const_cast&lt;const E2*&gt;(&amp;X2), const_cast&lt;const E3*&gt;(&amp;X3))</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">h</span>(args...) + args...); <span class="comment">// 展开成</span></span><br><span class="line"><span class="comment">// f(h(E1, E2, E3) + E1, h(E1, E2, E3) + E2, h(E1, E2, E3) + E3)</span></span><br></pre></td></tr></table></figure><p>正式而言，函数调用表达式中的表达式列表被归类为初始化器列表，它的模式是初始化器子句，它是赋值表达式和花括号初始化器列表其中之一。<br>有括号初始化器</p><p>包展开可以在直接初始化器，函数式转型及其他语境（成员初始化器，new 表达式等）的括号内出现，这种情况下的规则与适用于上述函数调用表达式的规则相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">c1</span><span class="params">(&amp;args...)</span></span>;             <span class="comment">// 调用 Class::Class(&amp;E1, &amp;E2, &amp;E3)</span></span><br><span class="line">Class c2 = <span class="built_in">Class</span>(n, ++args...); <span class="comment">// 调用 Class::Class(n, ++E1, ++E2, ++E3);</span></span><br><span class="line"> </span><br><span class="line">::<span class="keyword">new</span>((<span class="type">void</span> *)p) <span class="built_in">U</span>(std::forward&lt;Args&gt;(args)...) <span class="comment">// std::allocator::allocate</span></span><br></pre></td></tr></table></figure><p>花括号包围的初始化器</p><p>在花括号初始化器列表（花括号包围的初始化器和其他花括号初始化器列表的列表，用于列表初始化和其他一些语境中）中，也可以出现包展开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Ts... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="keyword">sizeof</span>...(args) + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> res[size] = &#123;<span class="number">1</span>, args..., <span class="number">2</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 因为初始化器列表保证顺序，所以这可以用来对包的每个元素按顺序调用函数：</span></span><br><span class="line">    <span class="type">int</span> dummy[<span class="keyword">sizeof</span>...(Ts)] = &#123;(std::cout &lt;&lt; args, <span class="number">0</span>)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板实参列表</p><p>包展开可以在模板实参列表的任何位置使用，前提是模板拥有与该展开相匹配的形参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> A, <span class="keyword">class</span> B, <span class="keyword">class</span>... C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A arg1, B arg2, C...arg3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    container&lt;A, B, C...&gt; t1; <span class="comment">// 展开成 container&lt;A, B, E1, E2, E3&gt; </span></span><br><span class="line">    container&lt;C..., A, B&gt; t2; <span class="comment">// 展开成 container&lt;E1, E2, E3, A, B&gt; </span></span><br><span class="line">    container&lt;A, C..., B&gt; t3; <span class="comment">// 展开成 container&lt;A, E1, E2, E3, B&gt; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数形参列表</p><p>在函数形参列表中，如果省略号在某个形参声明中（无论它是否指名函数形参包（例如在 Args … args中）出现，那么该形参声明是模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Ts...)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">f</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>); <span class="comment">// Ts... 会展开成 void f(char, int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0.1</span>);    <span class="comment">// Ts... 会展开成 void f(double)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts, <span class="type">int</span>... N&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(Ts (&amp;...arr)[N])</span> </span>&#123;&#125;</span><br><span class="line"><span class="type">int</span> n[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">g</span>&lt;<span class="type">const</span> <span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&quot;a&quot;</span>, n); <span class="comment">// Ts (&amp;...arr)[N] 会展开成 </span></span><br><span class="line">                            <span class="comment">// const char (&amp;)[2], int(&amp;)[1]</span></span><br></pre></td></tr></table></figure><p>注意：在模式 <code>Ts (&amp;...arr)[N]</code> 中，省略号是最内层的元素，而不是像所有其他包展开中一样是最后的元素。</p><p>注意：不能用 <code>Ts (&amp;...)[N]</code>，因为 C++11 语法要求带括号的省略号形参拥有名字：CWG 问题 1488。<br>模板形参列表</p><p>包展开可以在模板形参列表中出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">value_holder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;T... Values&gt; <span class="comment">// 会展开成非类型模板形参列表，</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">apply</span> &#123;&#125;;      <span class="comment">// 例如 &lt;int, char, int(&amp;)[5]&gt;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类说明符与成员初始化器列表</p><p>包展开可以用于指定类声明中的基类列表。通常这也意味着它的构造函数也需要在成员初始化器列表中使用包展开，以调用这些基类的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Mixins&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> : <span class="keyword">public</span> Mixins...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> Mixins&amp;... mixins) : <span class="built_in">Mixins</span>(mixins)... &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Lambda 捕获</p><p>包展开可以在 lambda 表达式的捕获子句中出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lm = [&amp;, args...] &#123; <span class="keyword">return</span> <span class="built_in">g</span>(args...); &#125;;</span><br><span class="line">    <span class="built_in">lm</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof… 运算符</p><p>sizeof… 也被归类为包展开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">count</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::<span class="type">size_t</span> value = <span class="keyword">sizeof</span>...(Types);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format)</span> <span class="comment">// 基础函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; format;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Targs&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, T value, Targs... Fargs)</span> <span class="comment">// 递归变参函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; *format != <span class="string">&#x27;\0&#x27;</span>; format++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *format == <span class="string">&#x27;%&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; value;</span><br><span class="line">            <span class="built_in">tprintf</span>(format + <span class="number">1</span>, Fargs...); <span class="comment">// 递归调用</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; *format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">tprintf</span>(<span class="string">&quot;% world% %\n&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="number">123</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：generalized (non-trivial) unions（推广的（非平凡）联合体）</title>
      <link href="/2022/08/30/C++/C++Feature/1.19.C++11-generalized_(non-trivial)_unions/"/>
      <url>/2022/08/30/C++/C++Feature/1.19.C++11-generalized_(non-trivial)_unions/</url>
      
        <content type="html"><![CDATA[<h2 id="联合体">联合体</h2><p>联合体是特殊的类类型，它在一个时刻只能保有其一个非静态数据成员。</p><p>联合体声明的类说明符与类或结构体的声明相似：<br>union 属性 类头名 { 成员说明 }</p><table><thead><tr><th style="text-align:right">名词</th><th>解释</th></tr></thead><tbody><tr><td style="text-align:right">属性</td><td>(C++11 起) 任意数量属性的可选序列</td></tr><tr><td style="text-align:right">类头名</td><td>被定义的联合体的名字。可以前附 嵌套名说明符（名字与作用域解析运算符的序列，以作用域解析运算符结尾）。可以忽略名字，此时联合体是无名的</td></tr><tr><td style="text-align:right">成员说明</td><td>访问说明符、成员对象和成员函数的声明与定义的列表。</td></tr></tbody></table><p>联合体可以拥有成员函数（包含构造函数和析构函数），但不能有虚函数。</p><p>联合体不能有基类且不能用作基类。</p><p>联合体不能拥有引用类型的非静态数据成员。</p><p>联合体不能含有带非平凡特殊成员函数（复制构造函数、复制赋值运算符或析构函数）的非静态数据成员。(C++11 前)</p><p>如果联合体含有带非平凡特殊成员函数（复制/移动构造函数，复制/移动赋值，或析构函数）的非静态数据成员，那么该联合体中的那些函数默认被弃置，且需要程序员显式定义。</p><p>如果联合体含有带非平凡默认构造函数的非静态数据成员，那么该联合体的默认构造函数默认被弃置，除非该联合体的变体成员拥有一个默认成员初始化器。</p><p>最多只有一个变体成员可以拥有默认成员初始化器。(C++11 起)</p><p>正如结构体的声明中一般，联合体的默认成员访问是 public。</p><p>联合体的大小仅足以保有其最大的数据成员。其他数据成员在该最大成员的一部分相同的字节分配。分配的细节是实现定义的，且读取并非最近写入的联合体成员是未定义行为。许多编译器以非标准语言扩展实现读取联合体的不活跃成员的能力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="type">int32_t</span> n;     <span class="comment">// 占用 4 字节</span></span><br><span class="line">    std::<span class="type">uint16_t</span> s[<span class="number">2</span>]; <span class="comment">// 占用 4 字节</span></span><br><span class="line">    std::<span class="type">uint8_t</span> c;     <span class="comment">// 占用 1 字节</span></span><br><span class="line">&#125;;                      <span class="comment">// 整个联合体占用 4 字节</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s = &#123;<span class="number">0x12345678</span>&#125;; <span class="comment">// 初始化首个成员，s.n 现在是活跃成员</span></span><br><span class="line">    <span class="comment">// 于此点，从 s.s 或 s.c 读取是未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;s.n = &quot;</span> &lt;&lt; s.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    s.s[<span class="number">0</span>] = <span class="number">0x0011</span>; <span class="comment">// s.s 现在是活跃成员</span></span><br><span class="line">    <span class="comment">// 在此点，从 n 或 c 读取是 UB 但大多数编译器都对其有定义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s.c 现在是 &quot;</span> &lt;&lt; +s.c &lt;&lt; <span class="string">&#x27;\n&#x27;</span> <span class="comment">// 11 或 00，取决于平台</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;s.n 现在是 &quot;</span> &lt;&lt; s.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 12340011 或 00115678</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.n = <span class="number">12345678</span></span><br><span class="line">s.c 现在是 <span class="number">0</span></span><br><span class="line">s.n 现在是 <span class="number">115678</span></span><br></pre></td></tr></table></figure><p>每个成员的分配都如同它是类的唯一成员一样。</p><p>如果联合体的成员是拥有用户定义的构造函数和析构函数的类，那么切换其活跃成员通常需要显式析构函数和布置 new：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    ~<span class="built_in">S</span>() &#123;&#125; <span class="comment">// 需要知道哪个成员活跃，只能在联合体式的类中做到</span></span><br><span class="line">&#125;;          <span class="comment">// 整个联合体占有 max(sizeof(string), sizeof(vector&lt;int&gt;)) 的内存</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s = &#123;<span class="string">&quot;Hello, world&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 在此点，从 s.vec 读取是未定义行为</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s.str = &quot;</span> &lt;&lt; s.str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    s.str.~<span class="built_in">basic_string</span>();</span><br><span class="line">    <span class="keyword">new</span> (&amp;s.vec) std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line">    <span class="comment">// 现在，s.vec 是联合体的活跃成员</span></span><br><span class="line">    s.vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; s.vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    s.vec.~<span class="built_in">vector</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.str = Hello, world</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="成员生存期">成员生存期</h2><p>联合体成员的生存期从该成员被设为活跃（active）时开始。如果之前已经有另一成员活跃，那么它的生存期终止。</p><p>当联合体的活跃成员通过形式为 E1 = E2 的复制表达式（使用内建赋值运算符或平凡的赋值运算符）切换时，对于 E1 中的各个成员访问和数组下标子表达式中出现的，其类型并非拥有非平凡或弃置的默认构造函数的类的每个联合体成员 X，如果 X 的修改在类型别名使用规则下会具有未定义行为，那么在所指名的存储中隐式创建一个 X 类型的对象；不进行初始化，且其生存期的开始按顺序晚于其左右的操作数的值计算，而早于赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">A</span> &#123; <span class="type">int</span> x; <span class="type">int</span> y[<span class="number">4</span>]; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; A a; &#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">C</span> &#123; B b; <span class="type">int</span> k; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c;               <span class="comment">// 不开始任何联合体成员的生存期</span></span><br><span class="line">  c.b.a.y[<span class="number">3</span>] = <span class="number">4</span>;    <span class="comment">// OK：&quot;c.b.a.y[3]&quot; 指名联合体成员 c.b 与 c.b.a.y;</span></span><br><span class="line">                     <span class="comment">// 这创建对象以保有联合体成员 c.b 和 c.b.a.y</span></span><br><span class="line">  <span class="keyword">return</span> c.b.a.y[<span class="number">3</span>]; <span class="comment">// OK：c.b.a.y 指代新创建的对象</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">const</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Y</span> &#123; X x; <span class="type">int</span> k; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Y y = &#123; &#123; <span class="number">1</span>, <span class="number">2</span> &#125; &#125;; <span class="comment">// OK，y.x 是联合体的活跃成员</span></span><br><span class="line">  <span class="type">int</span> n = y.x.a;</span><br><span class="line">  y.k = <span class="number">4</span>;   <span class="comment">// OK：结束 y.x 的生存期，y.k 是联合体的活跃成员</span></span><br><span class="line">  y.x.b = n; <span class="comment">// 未定义行为：y.x.b 在其生存期外被修改，</span></span><br><span class="line">             <span class="comment">// &quot;y.x.b&quot; 指名 y.x，但 X 的默认构造函数被弃置，</span></span><br><span class="line">             <span class="comment">// 所以联合体成员 y.x 的生存期不会隐式开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合体类型的平凡移动构造函数、移动赋值运算符、 (C++11 起)复制构造函数和复制赋值运算符复制对象表示。如果源与目标不是同一对象，那么这些特殊成员函数在复制前开始每个内嵌于目标的并对应内嵌于源的对象（除了既非目标的子对象亦不拥有隐式生存期类型的对象）的生存期。否则，它们不做任何事。在经由平凡特殊成员函数构造或赋值后，两个联合体对象拥有相同的对应活跃成员（如果存在）。</p><h2 id="匿名联合体">匿名联合体</h2><p>匿名联合体是不同时定义任何变量（包括联合体类型的对象、引用或指向联合体的指针）的无名的联合体定义。<br>union { 成员说明 } ;</p><p>匿名联合体有更多限制：它们不能有成员函数，不能有静态数据成员，且所有数据成员必须公开。只能声明非静态数据成员，外加static_assert 声明 (C++11 起)。</p><p>匿名联合体的成员被注入到它的外围作用域中（而且不得与其中声明的其他名字冲突）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* p;</span><br><span class="line">    &#125;;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    p = <span class="string">&quot;Jennifer&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间作用域的匿名联合体必须声明为 static，除非它们在无名命名空间出现。</p><h2 id="联合体式的类">联合体式的类</h2><p>联合体式的类（union-like class）是联合体，或是至少拥有一个匿名联合体成员的（非联合）类。联合体式的类拥有一组变体成员（variant member）：<br>其成员匿名联合体的非静态数据成员<br>另外，如果联合体式的类是联合体，则为其并非匿名联合体的非静态数据成员。</p><p>联合体式的类可用于实现带标签联合体（tagged union）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// S 拥有一个非静态数据成员（tag），三个枚举项成员（CHAR、INT、DOUBLE），</span></span><br><span class="line"><span class="comment">// 和三个变体成员（c、i、d）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span>&#123;CHAR, INT, DOUBLE&#125; tag;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_s</span><span class="params">(<span class="type">const</span> S&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(s.tag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> S::CHAR: std::cout &lt;&lt; s.c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S::INT: std::cout &lt;&lt; s.i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S::DOUBLE: std::cout &lt;&lt; s.d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S s = &#123;S::CHAR, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print_s</span>(s);</span><br><span class="line">    s.tag = S::INT;</span><br><span class="line">    s.i = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">print_s</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：type aliases（类型别名）</title>
      <link href="/2022/08/30/C++/C++Feature/1.17.C++11-type_aliases/"/>
      <url>/2022/08/30/C++/C++Feature/1.17.C++11-type_aliases/</url>
      
        <content type="html"><![CDATA[<h2 id="type-aliases（类型别名）">type aliases（类型别名）</h2><p>类型别名，别名模版 (C++11 起)</p><p>类型别名是指代【先前定义的类型】的名字（与 typedef 类似）。</p><p>别名模版是指代一族类型的名字。<br>语法</p><p>别名声明是具有下列语法的声明：</p><ul><li><strong>using 标识符 属性(可选) = 类型标识 ;</strong></li></ul><blockquote><p>类型别名声明引入一个名字，可用做 类型标识 所指代的类型的同义词。它不引入新类型，且不能更改既存类型名的含义。类型别名声明和 typedef 声明之间没有区别。此类声明可出现于块作用域、类作用域或命名空间作用域。</p></blockquote><ul><li><strong>template &lt; 模板形参列表 &gt;<br>using 标识符 属性(可选) = 类型标识 ;</strong></li></ul><blockquote><p>别名模板是一种模板，当其特化时等价于以别名模板的模板实参来替换 类型标识 中的模板形参的结果。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Alloc</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = vector&lt;T, Alloc&lt;T&gt;&gt;; <span class="comment">// 类型标识为 vector&lt;T, Alloc&lt;T&gt;&gt;</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; v; <span class="comment">// Vec&lt;int&gt; 等同于 vector&lt;int, Alloc&lt;int&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>当特化别名模板的结果是一个待决的模板标识时，对这个模板标识应用后继的替换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">void_t</span> = <span class="type">void</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void_t</span>&lt;<span class="keyword">typename</span> T::foo&gt; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// 错误，int 没有嵌套类型 foo</span></span><br></pre></td></tr></table></figure><p>特化别名模版时所生成的类型不允许直接或间接使用它自己的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> B = <span class="keyword">typename</span> A&lt;T&gt;::U; <span class="comment">// 类型标识为 A&lt;T&gt;::U</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="keyword">typedef</span> B&lt;T&gt; U; &#125;;</span><br><span class="line">B&lt;<span class="type">short</span>&gt; b; <span class="comment">// 错误：B&lt;short&gt; 通过 A&lt;short&gt;::U 使用其自身类型</span></span><br></pre></td></tr></table></figure><p>在推导模板模板形参时，模板实参推导始终不推导别名模板。<br>不能部分特化或显式特化别名模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类型别名，等同于</span></span><br><span class="line"><span class="comment">// typedef std::ios_base::fmtflags flags;</span></span><br><span class="line"><span class="keyword">using</span> flags = std::ios_base::fmtflags;</span><br><span class="line"><span class="comment">// 名字 &#x27;flags&#x27; 现在指代类型：</span></span><br><span class="line">flags fl = std::ios_base::dec;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类型别名，等同于</span></span><br><span class="line"><span class="comment">// typedef void (*func)(int, int);</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span> (*) (<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="comment">// 名字 &#x27;func&#x27; 现在指代函数指针：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">func f = example;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 别名模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> ptr = T*; </span><br><span class="line"><span class="comment">// 名字 &#x27;ptr&lt;T&gt;&#x27; 现在是指向 T 的指针的别名</span></span><br><span class="line">ptr&lt;<span class="type">int</span>&gt; x;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于隐藏模板形参的别名模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt;</span><br><span class="line"><span class="keyword">using</span> mystring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;&gt;;</span><br><span class="line">mystring&lt;<span class="type">char</span>&gt; str;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 别名模板可引入成员 typedef 名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span> &#123; <span class="keyword">using</span> value_type = T; &#125;;</span><br><span class="line"><span class="comment">// 可用于泛型编程</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ContainerType&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> ContainerType&amp; c)</span> </span>&#123; <span class="keyword">typename</span> ContainerType::value_type n; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于简化 std::enable_if 语法的类型别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Invoke = <span class="keyword">typename</span> T::type;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Condition&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIf = Invoke&lt;std::enable_if&lt;Condition::value&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">fpoly_only</span>(T t) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; <span class="keyword">virtual</span> ~<span class="built_in">S</span>() &#123;&#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Container&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="built_in">g</span>(c); <span class="comment">// Container::value_type 将在此函数中是 int</span></span><br><span class="line"><span class="comment">//  fpoly_only(c); // 错误：被 enable_if 禁止</span></span><br><span class="line">    S s;</span><br><span class="line">    <span class="built_in">fpoly_only</span>(s); <span class="comment">// OK：被 enable_if 允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：char16_t 与 char32_t（字符类型）</title>
      <link href="/2022/08/30/C++/C++Feature/1.16.C++11-char16_t_and_char32_t/"/>
      <url>/2022/08/30/C++/C++Feature/1.16.C++11-char16_t_and_char32_t/</url>
      
        <content type="html"><![CDATA[<h2 id="char16-t-与-char32-t（字符类型）">char16_t 与 char32_t（字符类型）</h2><p>char16_t - UTF-16 字符表示的类型，要求大到足以表示任何 UTF-16 编码单元（16 位）。它与 std::uint_least16_t 具有相同的大小、符号性和对齐，但它是独立的类型。<br>char32_t - UTF-32 字符表示的类型，要求大到足以表示任何 UTF-32 编码单元（32 位）。它与 std::uint_least32_t 具有相同的大小、符号性和对齐，但它是独立的类型。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：long long</title>
      <link href="/2022/08/30/C++/C++Feature/1.15.C++11-long_long/"/>
      <url>/2022/08/30/C++/C++Feature/1.15.C++11-long_long/</url>
      
        <content type="html"><![CDATA[<h2 id="整数类型">整数类型</h2><p>int - 基本整数类型。如果使用了下列任何修饰符就可以省略关键词 int。如果没有长度修饰符，那么它保证拥有至少 16 位宽度。然而在 32/64 位系统上，几乎专门保证它拥有至少 32 位宽度。</p><p>修饰符</p><p>修饰整数类型。能以任何顺序混合使用。类型名中每组只能有一个。</p><p>符号性</p><pre><code>signed - 目标类型将拥有有符号表示（默认符号性） unsigned - 目标类型将拥有无符号表示 </code></pre><p>大小</p><pre><code>short - 目标类型将为空间优化，且将有至少 16 位的宽度。 long - 目标类型将有至少 32 位的宽度。 long long - 目标类型将有至少 64 位的宽度。(C++11 起)</code></pre><p>注意：与所有类型说明符相同，容许采用任何顺序：unsigned long long int 与 long int unsigned long 指名同一类型。</p><p><img src="/assets/images/C++11-%E6%95%B4%E5%BD%A2%E4%BD%8D%E5%AE%BD.png" alt="C++11-整形位宽"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11： 指针字面量（nullptr）</title>
      <link href="/2022/08/30/C++/C++Feature/1.14.C++11-nullptr/"/>
      <url>/2022/08/30/C++/C++Feature/1.14.C++11-nullptr/</url>
      
        <content type="html"><![CDATA[<h2 id="指针字面量（nullptr）">指针字面量（nullptr）</h2><p>关键词 nullptr 代表指针字面量。它是 std::nullptr_t 类型的纯右值。存在从 nullptr 到任何指针类型及任何成员指针类型的隐式转换。同样的转换对于任何空指针常量也存在，空指针常量包括 std::nullptr_t 的值，以及宏 NULL。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">clone</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;函数 g 已调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(<span class="literal">nullptr</span>);        <span class="comment">// 良好</span></span><br><span class="line">    <span class="built_in">g</span>(<span class="literal">NULL</span>);           <span class="comment">// 良好</span></span><br><span class="line">    <span class="built_in">g</span>(<span class="number">0</span>);              <span class="comment">// 良好</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">g</span>(<span class="built_in">clone</span>(<span class="literal">nullptr</span>)); <span class="comment">// 良好</span></span><br><span class="line"><span class="comment">//  g(clone(NULL));    // 错误：非字面量的零不能为空指针常量</span></span><br><span class="line"><span class="comment">//  g(clone(0));       // 错误：非字面量的零不能为空指针常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">NULL 是一个宏定义</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#undef NULL</span></span><br><span class="line"><span class="comment">#if defined(__cpluscplus)</span></span><br><span class="line"><span class="comment">#defined NULL 0</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#define NULL ((void *)0)</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;invoke func(char*)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;invoke func(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>); <span class="comment">// call func(char*)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>); <span class="comment">// call func(int)</span></span><br><span class="line">    <span class="built_in">func</span>((<span class="type">char</span>*)<span class="number">0</span>); <span class="comment">// call func(char*)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>); <span class="comment">// call func(int)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：花括号或等号初始化器（initializers）</title>
      <link href="/2022/08/30/C++/C++Feature/1.13.C++11-initializers/"/>
      <url>/2022/08/30/C++/C++Feature/1.13.C++11-initializers/</url>
      
        <content type="html"><![CDATA[<h2 id="花括号或等号初始化器（initializers）">花括号或等号初始化器（initializers）</h2><p>变量的初始化会在构造时提供变量的初始值。</p><p>初始值可以由声明符或 new 表达式的初始化器部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。</p><p>对于每个声明符，初始化器必须是下列之一：</p><ul><li>( 表达式列表 ) // 括号中的以逗号分隔的含有任意表达式和花括号初始化器列表的列表</li><li>= 表达式 // 等号后面跟着一个表达式</li><li>{ 初始化器列表 } // 花括号初始化器列表：以逗号分隔且可以为空的含有表达式和其他花括号初始化器列表的列表</li></ul><p>根据上下文，初始化器可以调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string s&#123;&#125;; <span class="comment">// 值初始化</span></span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>; <span class="comment">// 直接初始化</span></span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 复制初始化</span></span><br><span class="line">std::string s&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;; <span class="comment">// 聚合初始化</span></span><br><span class="line"><span class="type">char</span>&amp; c = a[<span class="number">0</span>]; <span class="comment">// 引用初始化</span></span><br></pre></td></tr></table></figure><p>如果不提供初始化器，那么就会应用默认初始化的规则。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：字面类型（literal types）</title>
      <link href="/2022/08/30/C++/C++Feature/1.10.C++11-literal_types/"/>
      <url>/2022/08/30/C++/C++Feature/1.10.C++11-literal_types/</url>
      
        <content type="html"><![CDATA[<h2 id="字面类型（literal-types）">字面类型（literal types）</h2><p>指明一个类型为字面类型。字面类型是 constexpr 变量所拥有的类型，且能通过 constexpr 函数构造、操作及返回它们。</p><p>注意：标准中并没有定义具有这个名字的具名要求。这是核心语言所定义的一种类型类别。将它作为具名要求包含于此只是为了保持一致性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">conststr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p;</span><br><span class="line">    std::<span class="type">size_t</span> sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="title">conststr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>(&amp;a)[N])</span> : p(a), sz(N - <span class="number">1</span>) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">char</span> <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt; sz ? p[n] : <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sz; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">countlower</span><span class="params">(conststr s, std::<span class="type">size_t</span> n = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             std::<span class="type">size_t</span> c = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == s.<span class="built_in">size</span>() ? c :</span><br><span class="line">        s[n] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[n] &lt;= <span class="string">&#x27;z&#x27;</span> ? <span class="built_in">countlower</span>(s, n + <span class="number">1</span>, c + <span class="number">1</span>) :</span><br><span class="line">                                     <span class="built_in">countlower</span>(s, n + <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 要求编译时常量的输出函数，测试需要</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">constN</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">constN</span>() &#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\&quot;Hello, world!\&quot; 中小写字母的个数是 &quot;</span>;</span><br><span class="line">    <span class="built_in">constN</span>&lt;<span class="built_in">countlower</span>(<span class="string">&quot;Hello, world!&quot;</span>)&gt;(); <span class="comment">// 隐式转换成 conststr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：初始化列表（list initialization）</title>
      <link href="/2022/08/30/C++/C++Feature/1.11.C++11-list_initialization/"/>
      <url>/2022/08/30/C++/C++Feature/1.11.C++11-list_initialization/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化列表（list-initialization）">初始化列表（list initialization）</h2><p>从 花括号初始化器列表 列表初始化对象。</p><p>聚合体直接从同类型的单元素 花括号初始化器列表 进行复制/移动初始化，但非聚合体首先考虑 initializer_list 构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;&#125;; <span class="comment">// 聚合体</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span>     <span class="comment">// 非聚合体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Q</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Q</span>(Q <span class="type">const</span>&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Q</span>(std::initializer_list&lt;Q&gt;) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    X x2 = X&#123;x&#125;; <span class="comment">// 复制构造函数（非聚合初始化）</span></span><br><span class="line"> </span><br><span class="line">    Q q;</span><br><span class="line">    Q q2 = Q&#123;q&#125;; <span class="comment">// 初始化器列表构造函数（非复制构造函数）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; mem = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 非静态成员的列表初始化</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; mem2;</span><br><span class="line">    <span class="built_in">Foo</span>() : mem2&#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125; &#123;&#125; <span class="comment">// 构造函数中的成员列表初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">std::pair&lt;std::string, std::string&gt; <span class="title">f</span><span class="params">(std::pair&lt;std::string, std::string&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;p.second, p.first&#125;; <span class="comment">// return 语句中的列表初始化</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n0&#123;&#125;;  <span class="comment">// 值初始化（为零）</span></span><br><span class="line">    <span class="type">int</span> n1&#123;<span class="number">1</span>&#125;; <span class="comment">// 直接列表初始化</span></span><br><span class="line"> </span><br><span class="line">    std::string s1&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;; <span class="comment">// initializer_list 构造函数调用</span></span><br><span class="line">    std::string s2&#123;s1, <span class="number">2</span>, <span class="number">2</span>&#125;;           <span class="comment">// 常规构造函数调用</span></span><br><span class="line">    std::string s3&#123;<span class="number">0x61</span>, <span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">// initializer_list 构造函数偏好 (int, char)</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> n2 = &#123;<span class="number">1</span>&#125;; <span class="comment">// 复制列表初始化</span></span><br><span class="line">    <span class="type">double</span> d = <span class="type">double</span>&#123;<span class="number">1.2</span>&#125;; <span class="comment">// 纯右值的列表初始化，然后复制初始化</span></span><br><span class="line">    <span class="keyword">auto</span> s4 = std::string&#123;<span class="string">&quot;HelloWorld&quot;</span>&#125;; <span class="comment">// 同上， C++17 起不创建临时对象</span></span><br><span class="line"> </span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m = <span class="comment">// 嵌套列表初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, s1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f</span>(&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;).first <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line">              &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">int</span> <span class="params">(&amp;ar)</span>[2] </span>= &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 绑定左值引用到临时数组</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; r1 = &#123;<span class="number">1</span>&#125;; <span class="comment">// 绑定右值引用到临时 int</span></span><br><span class="line"><span class="comment">//  int&amp; r2 = &#123;2&#125;; // 错误：不能绑定右值到非 const 左值引用</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  int bad&#123;1.0&#125;; // 错误：窄化转换</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc1&#123;<span class="number">10</span>&#125;; <span class="comment">// 可以</span></span><br><span class="line"><span class="comment">//  unsigned char uc2&#123;-1&#125;; // 错误：窄化转换</span></span><br><span class="line"> </span><br><span class="line">    Foo f;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; n0 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; s1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p: m)</span><br><span class="line">        std::cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n: f.mem)</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> n: f.mem2)</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：委托与继承的构造函数 （delegating and inherited constructors）</title>
      <link href="/2022/08/30/C++/C++Feature/1.12.C++11-delegating_and_inherited_constructors/"/>
      <url>/2022/08/30/C++/C++Feature/1.12.C++11-delegating_and_inherited_constructors/</url>
      
        <content type="html"><![CDATA[<h2 id="委托构造函数">委托构造函数</h2><p>如果类自身的名字在初始化器列表中作为 类或标识符 出现，那么该列表只能由这一个成员初始化器组成；这种构造函数被称为委托构造函数（delegating constructor），而构造函数列表的仅有成员所选择的构造函数是目标构造函数。</p><p>此时首先由重载决议选择目标构造函数并予以执行，然后控制返回到委托构造函数并执行其函数体。</p><p>委托构造函数不能递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">char</span> x, <span class="type">int</span> y) &#123;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> y) : <span class="built_in">Foo</span>(<span class="string">&#x27;a&#x27;</span>, y) &#123;&#125; <span class="comment">// Foo(int) 委托到 Foo(char, int)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Class</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> y;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg;</span><br><span class="line">    std::fstream f;</span><br><span class="line">    std::string s;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Class</span>(<span class="type">int</span> x) : Base&#123;<span class="number">123</span>&#125;, <span class="comment">// 初始化基类</span></span><br><span class="line">        <span class="built_in">x</span> (x),  <span class="comment">// x（成员）以 x（形参）初始化</span></span><br><span class="line">        y &#123;<span class="number">0</span>&#125;,  <span class="comment">// y 初始化为 0</span></span><br><span class="line">        f&#123;<span class="string">&quot;test.cc&quot;</span>, std::ios::app&#125;, <span class="comment">// 在 m 和 lg 初始化之后发生</span></span><br><span class="line">        <span class="built_in">s</span>(__func__), <span class="comment">//__func__ 可用，因为初始化器列表是构造函数的一部分</span></span><br><span class="line">        <span class="built_in">lg</span> (m), <span class="comment">// lg 使用已经初始化的 m</span></span><br><span class="line">        m&#123;&#125;     <span class="comment">// m 在 lg 前初始化，即使它最后出现在此处</span></span><br><span class="line">    &#123;&#125;          <span class="comment">// 空复合语句</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Class</span>(<span class="type">double</span> a) : <span class="built_in">y</span>(a + <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">x</span>(y), <span class="comment">// x 将在 y 前初始化，它的值不确定</span></span><br><span class="line">        <span class="built_in">lg</span>(m)</span><br><span class="line">    &#123;&#125; <span class="comment">// 基类初始化器未在列表中出现，它被默认初始化（这与使用 Base() 不同，那是值初始化）</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Class</span>()</span><br><span class="line">    <span class="keyword">try</span> <span class="comment">// 函数 try 块在包含初始化器列表的函数体之前开始</span></span><br><span class="line">      : <span class="built_in">Class</span>(<span class="number">0.0</span>) <span class="comment">// 委托构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化中发生的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class c;</span><br><span class="line">    <span class="function">Class <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">c2</span><span class="params">(<span class="number">0.1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承的构造函数">继承的构造函数</h2><p>初始化顺序</p><p>列表中的成员初始化器的顺序是不相关的：初始化的实际顺序如下：</p><ol><li>如果构造函数是最终派生类的，那么按基类声明的深度优先、从左到右的遍历中的出现顺序（从左到右指的是基说明符列表中所呈现的），初始化各个虚基类</li><li>然后，以在此类的基类说明符列表中出现的从左到右顺序，初始化各个直接基类</li><li>然后，以类定义中的声明顺序，初始化各个非静态成员。</li><li>最后，执行构造函数体</li></ol><p>（注意：如果初始化的顺序是由不同构造函数中的成员初始化器列表中的出现所控制，那么析构函数就无法确保销毁顺序是构造顺序的逆序了）<br>继承构造函数</p><p>如果 using 声明指代了正在定义的类的某个直接基类的构造函数（例如 using Base::Base;），那么在初始化派生类时，该基类的所有构造函数（忽略成员访问）均对重载决议可见。</p><p>如果重载决议选择了继承的构造函数，那么如果它被用于构造相应基类的对象时可访问，它也是可访问的：引入它的 using 声明的可访问性被忽略。</p><p>如果在初始化这种派生类对象时重载决议选择了继承的构造函数之一，那么用这个继承的构造函数对从之继承该构造函数的 Base 子对象进行初始化，而 Derived 的所有其他基类和成员，都如同以预置的默认构造函数一样进行初始化（如果提供默认成员初始化器就会使用它，否则进行默认初始化）。整个初始化被视作单个函数调用：继承的构造函数的各形参的初始化，按顺序早于派生类对象的任何基类或成员的初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B1</span> &#123; <span class="built_in">B1</span>(<span class="type">int</span>, ...) &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B2</span> &#123; <span class="built_in">B2</span>(<span class="type">double</span>)   &#123;&#125; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> B1::B1; <span class="comment">// 继承 B1(int, ...)</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">get</span>();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">D1 <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// OK：B1 通过调用 B1(2, 3, 4) 初始化，</span></span><br><span class="line">                   <span class="comment">// 然后 d.x 被默认初始化（不进行初始化），</span></span><br><span class="line">                   <span class="comment">// 然后 d.y 通过调用 get() 初始化</span></span><br><span class="line"> </span><br><span class="line">    D1 e;          <span class="comment">// 错误：D1 没有默认构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> B2::B2; <span class="comment">// 继承 B2(double)</span></span><br><span class="line">    B1 b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">D2 <span class="title">f</span><span class="params">(<span class="number">1.0</span>)</span></span>; <span class="comment">// 错误：B1 没有默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">W</span> &#123; <span class="built_in">W</span>(<span class="type">int</span>); &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> : <span class="keyword">virtual</span> W</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> W::W; <span class="comment">// 继承 W(int)</span></span><br><span class="line">    <span class="built_in">X</span>() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> : X</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> X::X;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Z</span> : Y, <span class="keyword">virtual</span> W</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Y::Y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">Z <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// OK：Y 的初始化不会调用 X 的默认构造函数</span></span><br></pre></td></tr></table></figure><p>如果构造函数从 B 类型的多个基类子对象继承，那么程序非良构，这与多继承的非静态成员函数相似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="built_in">A</span>(<span class="type">int</span>); &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123; <span class="keyword">using</span> A::A; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C1</span> : B &#123; <span class="keyword">using</span> B::B; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span> : B &#123; <span class="keyword">using</span> B::B; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : C1, C2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> C1::C1;</span><br><span class="line">    <span class="keyword">using</span> C2::C2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">D1 <span class="title">d1</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 非良构：从不同的 B 基类子对象继承的构造函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V1</span> : <span class="keyword">virtual</span> B &#123; <span class="keyword">using</span> B::B; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V2</span> : <span class="keyword">virtual</span> B &#123; <span class="keyword">using</span> B::B; &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : V1, V2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> V1::V1;</span><br><span class="line">    <span class="keyword">using</span> V2::V2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">D2 <span class="title">d2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// OK：只有一个 B 子对象。</span></span><br><span class="line">          <span class="comment">// 这会初始化虚 B 基类，它初始化 A 基类</span></span><br><span class="line">          <span class="comment">// 然后如同用预置的默认构造函数</span></span><br><span class="line">          <span class="comment">// 初始化 V1 与 V2 基类</span></span><br></pre></td></tr></table></figure><p>与任何其他非静态成员函数的 using 声明相同，如果继承的构造函数的签名与 Derived 的构造函数之一匹配，那么它被 Derived 中找到的版本从查找中隐藏。如果 Base 的继承构造函数恰好有与 Derived 的复制/移动构造函数匹配的签名，那么它不妨碍 Derived 复制/移动构造函数的隐式生成（然后继承的版本被它隐藏，这与 using operator= 类似）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B1</span> &#123; <span class="built_in">B1</span>(<span class="type">int</span>); &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B2</span> &#123; <span class="built_in">B2</span>(<span class="type">int</span>); &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B1, B2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> B1::B1;</span><br><span class="line">    <span class="keyword">using</span> B2::B2;</span><br><span class="line">    <span class="built_in">D2</span>(<span class="type">int</span>); <span class="comment">// OK：D2::D2(int) 会隐藏 B1::B1(int) 和 B2::B2(int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">D2 <span class="title">d2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 调用 D2::D2(int)</span></span><br><span class="line"></span><br><span class="line">在模板化类中，如果 <span class="keyword">using</span> 声明指代待决名，而 嵌套名说明符 拥有与该 无限定标识 相同的终止名，那么认为它指名构造函数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> : T</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> T::T; <span class="comment">// OK：继承 T 的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : T, A&lt;U&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> A&lt;U&gt;::A; <span class="comment">// OK：继承 A&lt;U&gt; 的构造函数</span></span><br><span class="line">    <span class="keyword">using</span> T::A;    <span class="comment">// 不继承 T 的构造函数，尽管 T 可以是 A&lt;&gt; 的特化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：常量表达式（constexpr）</title>
      <link href="/2022/08/30/C++/C++Feature/1.9.C++11-constexpr/"/>
      <url>/2022/08/30/C++/C++Feature/1.9.C++11-constexpr/</url>
      
        <content type="html"><![CDATA[<h2 id="constexpr-说明符">constexpr 说明符</h2><p>constexpr - 指定变量或函数的值可以在常量表达式中出现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 constexpr 函数使用递归而非迭代</span></span><br><span class="line"><span class="comment">// （C++14 constexpr 函数可使用局部变量和循环）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * <span class="built_in">factorial</span>(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 字面类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">conststr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p;</span><br><span class="line">    std::<span class="type">size_t</span> sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> N&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="title">conststr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>(&amp;a)[N])</span>: p(a), sz(N - <span class="number">1</span>) &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constexpr 函数通过抛异常来提示错误</span></span><br><span class="line">    <span class="comment">// C++11 中，它们必须用条件运算符 ?: 来这么做</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">char</span> <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt; sz ? p[n] : <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sz; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++11 constexpr 函数必须把一切放在单条 return 语句中</span></span><br><span class="line"><span class="comment">// （C++14 无此要求）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">countlower</span><span class="params">(conststr s, std::<span class="type">size_t</span> n = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             std::<span class="type">size_t</span> c = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == s.<span class="built_in">size</span>() ? c :</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span> &lt;= s[n] &amp;&amp; s[n] &lt;= <span class="string">&#x27;z&#x27;</span> ? <span class="built_in">countlower</span>(s, n + <span class="number">1</span>, c + <span class="number">1</span>) :</span><br><span class="line">                                     <span class="built_in">countlower</span>(s, n + <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出要求编译时常量的函数，用于测试</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">constN</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">constN</span>() &#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4! = &quot;</span> ;</span><br><span class="line">    constN&lt;<span class="built_in">factorial</span>(<span class="number">4</span>)&gt; out1; <span class="comment">// 在编译时计算</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> k = <span class="number">8</span>; <span class="comment">// 使用 volatile 防止优化</span></span><br><span class="line">    std::cout &lt;&lt; k &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(k) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 运行时计算</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\&quot;Hello, world!\&quot; 里小写字母的个数是 &quot;</span>;</span><br><span class="line">    constN&lt;<span class="built_in">countlower</span>(<span class="string">&quot;Hello, world!&quot;</span>)&gt; out2; <span class="comment">// 隐式转换到常量字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：移动赋值运算符（move assignment operators）</title>
      <link href="/2022/08/30/C++/C++Feature/1.7.C++11-move_assignment_operators/"/>
      <url>/2022/08/30/C++/C++Feature/1.7.C++11-move_assignment_operators/</url>
      
        <content type="html"><![CDATA[<h2 id="移动赋值运算符">移动赋值运算符</h2><p>类 T 的移动赋值运算符是名为 operator= 的非模板非静态成员函数，它接受恰好一个 T&amp;&amp;、const T&amp;&amp;、volatile T&amp;&amp; 或 const volatile T&amp;&amp; 类型的形参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string s;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">s</span>(<span class="string">&quot;测试&quot;</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; o) : <span class="built_in">s</span>(o.s) &#123; std::cout &lt;&lt; <span class="string">&quot;移动失败！\n&quot;</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; o) : <span class="built_in">s</span>(std::<span class="built_in">move</span>(o.s)) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">         s = other.s;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;复制赋值\n&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">         s = std::<span class="built_in">move</span>(other.s);</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;移动赋值\n&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(A a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A</span><br><span class="line">&#123;</span><br><span class="line">    std::string s2; </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 隐式移动赋值运算符 B&amp; B::operator=(B&amp;&amp;)</span></span><br><span class="line">    <span class="comment">// 调用 A 的移动赋值运算符</span></span><br><span class="line">    <span class="comment">// 调用 s2 的移动赋值运算符</span></span><br><span class="line">    <span class="comment">// 并进行 n 的逐位复制</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123;&#125; <span class="comment">// 析构函数阻止隐式移动赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">D</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">D</span>() &#123;&#125; <span class="comment">// 析构函数本会阻止隐式移动赋值</span></span><br><span class="line">    D&amp; <span class="keyword">operator</span>=(D&amp;&amp;) = <span class="keyword">default</span>; <span class="comment">// 无论如何都强制移动赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试从右值临时量移动赋值 A\n&quot;</span>;</span><br><span class="line">    a1 = <span class="built_in">f</span>(<span class="built_in">A</span>()); <span class="comment">// 从右值临时量移动赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试从亡值移动赋值 A\n&quot;</span>;</span><br><span class="line">    a2 = std::<span class="built_in">move</span>(a1); <span class="comment">// 从亡值移动赋值</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试移动赋值 B\n&quot;</span>;</span><br><span class="line">    B b1, b2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移动前，b1.s = \&quot;&quot;</span> &lt;&lt; b1.s &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    b2 = std::<span class="built_in">move</span>(b1); <span class="comment">// 调用隐式移动赋值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移动后，b1.s = \&quot;&quot;</span> &lt;&lt; b1.s &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试移动赋值 C\n&quot;</span>;</span><br><span class="line">    C c1, c2;</span><br><span class="line">    c2 = std::<span class="built_in">move</span>(c1); <span class="comment">// 调用复制赋值运算符</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试移动赋值 D\n&quot;</span>;</span><br><span class="line">    D d1, d2;</span><br><span class="line">    d2 = std::<span class="built_in">move</span>(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：有作用域枚举（scoped enums）</title>
      <link href="/2022/08/30/C++/C++Feature/1.8.C++11-scoped_enums/"/>
      <url>/2022/08/30/C++/C++Feature/1.8.C++11-scoped_enums/</url>
      
        <content type="html"><![CDATA[<h2 id="有作用域枚举">有作用域枚举</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">struct</span>|<span class="keyword">class</span> 名字 &#123; 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... &#125;</span><br><span class="line"><span class="comment">// 声明底层类型为 int 的有作用域枚举类型（关键词 class 与 struct 完全等价）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">struct</span>|<span class="keyword">class</span> 名字 : 类型 &#123; 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... &#125;</span><br><span class="line"><span class="comment">// 声明底层类型为 类型 的有作用域枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">struct</span>|<span class="keyword">class</span> 名字 ;</span><br><span class="line"><span class="comment">// 底层类型为 int 的有作用域枚举类型的不可见枚举声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">struct</span>|<span class="keyword">class</span> 名字 : 类型 ;</span><br><span class="line"><span class="comment">// 底层类型为 类型 的有作用域枚举类型的不可见枚举声明</span></span><br></pre></td></tr></table></figure><p>每个 枚举项 都成为该枚举的类型（即 名字）的具名常量，它被该枚举的作用域所包含，且可用作用域解析运算符访问。没有从有作用域枚举项到整数类型的隐式转换，尽管 static_cast 可以用来获得枚举项的数值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; red, green = <span class="number">20</span>, blue &#125;;</span><br><span class="line">Color r = Color::blue;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span>(r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Color::red  : std::cout &lt;&lt; <span class="string">&quot;红\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::green: std::cout &lt;&lt; <span class="string">&quot;绿\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Color::blue : std::cout &lt;&lt; <span class="string">&quot;蓝\n&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// int n = r; // 错误：不存在从有作用域枚举到 int 的隐式转换</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(r); <span class="comment">// OK, n = 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Type</span> &#123; General, Light, Medium, Heavy &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TypeC</span> :<span class="type">char</span> &#123; General, Light, Medium, Heavy &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TypeUI</span> :<span class="type">unsigned</span> <span class="type">int</span> &#123; General, Light, Medium, Heavy &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：移动构造函数（move constructors）</title>
      <link href="/2022/08/30/C++/C++Feature/1.6.C++11-move_constructors/"/>
      <url>/2022/08/30/C++/C++Feature/1.6.C++11-move_constructors/</url>
      
        <content type="html"><![CDATA[<h2 id="移动构造函数">移动构造函数</h2><p>类 T 的移动构造函数是非模板构造函数，它的首个形参是 T&amp;&amp;、const T&amp;&amp;、volatile T&amp;&amp; 或 const volatile T&amp;&amp;，且没有其他形参，或剩余形参均有默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">s</span>(<span class="string">&quot;测试&quot;</span>), <span class="built_in">k</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; o) : <span class="built_in">s</span>(o.s), <span class="built_in">k</span>(o.k) &#123; std::cout &lt;&lt; <span class="string">&quot;移动失败！\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; o) <span class="keyword">noexcept</span> :</span><br><span class="line">        <span class="built_in">s</span>(std::<span class="built_in">move</span>(o.s)),       <span class="comment">// 类类型成员的显式移动</span></span><br><span class="line">        <span class="built_in">k</span>(std::<span class="built_in">exchange</span>(o.k, <span class="number">0</span>)) <span class="comment">// 非类类型成员的显式移动</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A</span><br><span class="line">&#123;</span><br><span class="line">    std::string s2;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 隐式移动构造函数 B::(B&amp;&amp;)</span></span><br><span class="line">    <span class="comment">// 调用 A 的移动构造函数</span></span><br><span class="line">    <span class="comment">// 调用 s2 的移动构造函数</span></span><br><span class="line">    <span class="comment">// 并进行 n 的逐位复制</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123;&#125; <span class="comment">// 析构函数阻止隐式移动构造函数 C::(C&amp;&amp;)</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">D</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">D</span>() &#123;&#125;           <span class="comment">// 析构函数阻止隐式移动构造函数 D::(D&amp;&amp;)</span></span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp;) = <span class="keyword">default</span>; <span class="comment">// 强制生成移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试移动 A\n&quot;</span>;</span><br><span class="line">    A a1 = <span class="built_in">f</span>(<span class="built_in">A</span>()); <span class="comment">// 按值返回时，从函数形参移动构造其目标</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移动前，a1.s = &quot;</span> &lt;&lt; std::<span class="built_in">quoted</span>(a1.s)</span><br><span class="line">        &lt;&lt; <span class="string">&quot; a1.k = &quot;</span> &lt;&lt; a1.k &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    A a2 = std::<span class="built_in">move</span>(a1); <span class="comment">// 从亡值移动构造</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移动后，a1.s = &quot;</span> &lt;&lt; std::<span class="built_in">quoted</span>(a1.s)</span><br><span class="line">        &lt;&lt; <span class="string">&quot; a1.k = &quot;</span> &lt;&lt; a1.k &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试移动 B\n&quot;</span>;</span><br><span class="line">    B b1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移动前，b1.s = &quot;</span> &lt;&lt; std::<span class="built_in">quoted</span>(b1.s) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    B b2 = std::<span class="built_in">move</span>(b1); <span class="comment">// 调用隐式移动构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移动后，b1.s = &quot;</span> &lt;&lt; std::<span class="built_in">quoted</span>(b1.s) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试移动 C\n&quot;</span>;</span><br><span class="line">    C c1;</span><br><span class="line">    C c2 = std::<span class="built_in">move</span>(c1); <span class="comment">// 调用复制构造函数</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;尝试移动 D\n&quot;</span>;</span><br><span class="line">    D d1;</span><br><span class="line">    D d2 = std::<span class="built_in">move</span>(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移动语义和完美转发">移动语义和完美转发</h2><p>左值/右值（两种判断方法）<br>1.在赋值表达式中，出现在等号左边的就是左值，而在等号右边的则是右值。<br>2.可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值。</p><p>移动语义<br>“偷走”临时变量中资源的构造函数，称为“移动构造函数”，“偷”的行为，则称为“移动语义”。</p><p>完美转发<br>在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。</p><pre><code class="language-cpp">#include &lt;iostream&gt;using namespace std;// 浅拷贝class TestShollowCopy &#123;public:    TestShollowCopy():data(new int(1))&#123;&#125;    TestShollowCopy(const TestShollowCopy&amp; other) :data(other.data) &#123;&#125;    ~TestShollowCopy() &#123; delete data; &#125;private:    int* data;&#125;;// 深拷贝class TestDeepCopy &#123;public:    TestDeepCopy() :data(new int(1)) &#123;&#125;    TestDeepCopy(const TestDeepCopy&amp; other) :data(new int(*other.data)) &#123;&#125;    ~TestDeepCopy() &#123; delete data; &#125;private:    int* data;&#125;;class TestCopy &#123;public:    TestCopy() :data(new int(1)) &#123;        cout &lt;&lt; &quot;Default construct: &quot; &lt;&lt; ++nsc &lt;&lt; endl;     &#125;    TestCopy(const TestCopy&amp;other) :data(new int(*other.data)) &#123;        cout &lt;&lt; &quot;Copy construct: &quot; &lt;&lt; ++ndc &lt;&lt; endl;     &#125;    // 移动构造函数    TestCopy(TestCopy&amp;&amp; other) :data(other.data) &#123;        other.data = nullptr; // 将临时值的指针成员置空        cout &lt;&lt; &quot;Move construct: &quot; &lt;&lt; ++nmc &lt;&lt; endl;    &#125;    ~TestCopy() &#123;         delete data;        cout &lt;&lt; &quot;Delete construct: &quot; &lt;&lt; ++nd &lt;&lt; endl;    &#125;//private:    int* data;    static int nsc;    static int ndc;    static int nmc;    static int nd;&#125;;int TestCopy::nsc = 0;int TestCopy::ndc = 0;int TestCopy::nmc = 0;int TestCopy::nd = 0;TestCopy GetTemp() &#123;    TestCopy t;    cout &lt;&lt; __func__ &lt;&lt; &quot;: &quot; &lt;&lt; hex &lt;&lt; t.data &lt;&lt; endl;    return t;&#125;// Copyable struct Copyable &#123;    Copyable() &#123;&#125;    Copyable(const Copyable&amp; o) &#123; cout &lt;&lt; __func__ &lt;&lt; endl; &#125;&#125;;Copyable ReturnRvalue() &#123; return Copyable(); &#125;void AcceptVal(Copyable) &#123;&#125;void AcceptRef(const Copyable &amp;) &#123;&#125;// std::moveclass Moveable &#123;public:    Moveable() : i(new int(2)) &#123;&#125;    ~Moveable() &#123; delete i; &#125;    Moveable(const Moveable &amp;o) : i(new int(*o.i)) &#123;&#125;    Moveable(Moveable &amp;&amp;o) :i(o.i) &#123;        o.i = nullptr;    &#125;    int *i;&#125;;Moveable GetTemp1() &#123;    Moveable tmp = Moveable();    cout &lt;&lt; __func__ &lt;&lt; &quot;: &quot; &lt;&lt; hex &lt;&lt; tmp.i &lt;&lt; endl;    return tmp;&#125;// move_if_noexcept 替代 move （牺牲性能保证安全的一种做法）// 在类的移动构造函数没有 noexcept 关键字修饰时返回一个左值引用，从而使变量可以使用拷贝语义// 而在类的移动构造函数有 noexcept 关键字时，返回一个右值引用，从而使变量可以使用移动语义struct Maythrow &#123;    Maythrow() &#123;&#125;    Maythrow(const Maythrow&amp;) &#123; cout &lt;&lt; &quot;Maythrow copy constructor.&quot; &lt;&lt; endl; &#125;    Maythrow(Maythrow&amp;&amp;) &#123; cout &lt;&lt; &quot;Maythrow move constructor.&quot; &lt;&lt; endl; &#125;&#125;;struct Nothrow &#123;    Nothrow() &#123;&#125;    Nothrow(const Nothrow&amp;) &#123; cout &lt;&lt; &quot;Nothrow copy constructor.&quot; &lt;&lt; endl; &#125;    Nothrow(Nothrow&amp;&amp;) noexcept &#123; cout &lt;&lt; &quot;Nothrow move constructor.&quot; &lt;&lt; endl; &#125;&#125;;// 完美转发void RunCode(int&amp;&amp; i) &#123; cout &lt;&lt; &quot;rvalue ref&quot; &lt;&lt; endl; &#125;void RunCode(int&amp; i) &#123; cout &lt;&lt; &quot;lvalue ref&quot; &lt;&lt; endl; &#125;void RunCode(const int&amp;&amp; i) &#123; cout &lt;&lt; &quot;const rvalue ref&quot; &lt;&lt; endl; &#125;void RunCode(const int&amp; i) &#123; cout &lt;&lt; &quot;const lvalue ref&quot; &lt;&lt; endl; &#125;// 完美转发的作用就是做包装函数template&lt;typename T&gt;void PerfectForward(T&amp;&amp; t) &#123; RunCode(forward&lt;T&gt;(t)); &#125;void RunCode1(double&amp;&amp; m) &#123;&#125;void RunHome(double&amp;&amp; m) &#123;&#125;void RunComp(double&amp;&amp; m) &#123;&#125;template&lt;typename T, typename U&gt;void PerfectForward(T&amp;&amp; t, U&amp; func)&#123;    cout &lt;&lt; t &lt;&lt; &quot;\tforwarded...&quot; &lt;&lt; endl;    func(forward&lt;T&gt;(t));&#125;int main()&#123;    TestDeepCopy dc;    TestDeepCopy dc1(dc);    // dc.data 和 dc1.data 指向同一块堆内存，当析构其中之一后，另一个就成了“悬挂指针”，    // 那么在该悬挂指针上释放内存就会造成严重的错误    TestShollowCopy sc;    //TestShollowCopy sc1(sc); // error    TestCopy t = GetTemp();    cout &lt;&lt; __func__ &lt;&lt; &quot;: &quot; &lt;&lt; hex &lt;&lt; t.data &lt;&lt; endl;    // t.data 和 GetTemp() 中的t.data地址是一样的，因为TestCopy类实现了移动构造函数    //     // 禁止优化，才可以看到效果：g++ -std=c++11 C++11_rvalue_ref_move_semantics.cpp -fno-elide-constructors     cout &lt;&lt; &quot;pass by value: &quot; &lt;&lt; endl;    AcceptVal(ReturnRvalue());    cout &lt;&lt; &quot;pass by reference: &quot; &lt;&lt; endl;    AcceptRef(ReturnRvalue());    Moveable m;    Moveable m1(move(m));    // cout &lt;&lt; *m.i &lt;&lt; endl; // error: m.i被m1的移动构造函数设置为nullptr，由于m的生命周期为main()函数，那么调用*m.i的时候会发生严重的运行时错误    cout &lt;&lt; *m1.i &lt;&lt; endl;    Moveable m2(GetTemp1());    Maythrow maythrorw;    Maythrow mt = move_if_noexcept(maythrorw); // copy    Nothrow nothrow;    Nothrow nt = move_if_noexcept(nothrow); // move        int i, j;    const int ci = 1;    const int cj = 0;    PerfectForward(i);       // lvalue ref    PerfectForward(move(j)); // rvalue ref    PerfectForward(ci);      // const lvalue ref    PerfectForward(move(cj));// const rvalue ref    PerfectForward(1.2, RunCode1);    PerfectForward(4, RunComp);    PerfectForward(6.2, RunHome);    return 0;&#125;// g++ -std=c++11 C++11_rvalue_ref_move_semantics.cpp -fno-elide-constructors (关闭优化)</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：右值引用（rvalue references）</title>
      <link href="/2022/08/29/C++/C++Feature/1.5.C++11-rvalue_references/"/>
      <url>/2022/08/29/C++/C++Feature/1.5.C++11-rvalue_references/</url>
      
        <content type="html"><![CDATA[<p>声明具名变量为引用，即既存对象或函数的别名。</p><ol><li>左值引用声明符：声明 S&amp; D; 是将 D 声明为 声明说明符序列 S 所确定的类型的左值引用。</li><li>右值引用声明符：声明 S&amp;&amp; D; 是将 D 声明为 声明说明符序列 S 所确定的类型的右值引用。</li></ol><p>引用必须被初始化为指代一个有效的对象或函数：见引用初始化。</p><p>不存在 void 的引用，也不存在引用的引用。</p><p>引用不是对象；它们不必占用存储，尽管编译器会在需要实现所需语义（例如，引用类型的非静态数据成员通常会增加类的大小，量为存储内存地址所需）的情况下分配存储。</p><p>因为引用不是对象，所以不存在引用的数组，不存在指向引用的指针，不存在引用的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; a[<span class="number">3</span>]; <span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span>&amp;* p;   <span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span>&amp; &amp;r;   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h2 id="引用折叠">引用折叠</h2><p>通过模板或 typedef 中的类型操作可以构成引用的引用，此时适用引用折叠（reference collapsing）规则：右值引用的右值引用折叠成右值引用，所有其他组合均折叠成左值引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp;  lref;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp;&amp; rref;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"> </span><br><span class="line">lref&amp;  r1 = n; <span class="comment">// r1 的类型是 int&amp;</span></span><br><span class="line">lref&amp;&amp; r2 = n; <span class="comment">// r2 的类型是 int&amp;</span></span><br><span class="line">rref&amp;  r3 = n; <span class="comment">// r3 的类型是 int&amp;</span></span><br><span class="line">rref&amp;&amp; r4 = <span class="number">1</span>; <span class="comment">// r4 的类型是 int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>（这条规则，和将 T&amp;&amp; 用于函数模板时的模板实参推导的特殊规则一起，组成了使得 std::forward 可行的规则。）</p><h2 id="左值引用">左值引用</h2><p>左值引用可用于建立既存对象的别名（可拥有不同的 cv 限定）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;Ex&quot;</span>;</span><br><span class="line">    std::string&amp; r1 = s;</span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s;</span><br><span class="line"> </span><br><span class="line">    r1 += <span class="string">&quot;ample&quot;</span>;           <span class="comment">// 修改 s</span></span><br><span class="line"><span class="comment">//  r2 += &quot;!&quot;;               // 错误：不能通过到 const 的引用修改</span></span><br><span class="line">    std::cout &lt;&lt; r2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 打印 s，它现在保有 &quot;Example&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们也能用于在函数调用中实现按引用传递语义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">double_string</span><span class="params">(std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s += s; <span class="comment">// &#x27;s&#x27; 与 main() 的 &#x27;str&#x27; 是同一对象</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    <span class="built_in">double_string</span>(str);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数的返回值是左值引用时，函数调用表达式变成左值表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">char_number</span><span class="params">(std::string&amp; s, std::<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">at</span>(n); <span class="comment">// string::at() 返回 char 的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">    <span class="built_in">char_number</span>(str, <span class="number">1</span>) = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 函数调用是左值，可被赋值</span></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右值引用">右值引用</h2><p>右值引用可用于为临时对象延长生存期（注意，到 const 的左值引用也能延长临时对象生存期，但这些对象无法因此被修改）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line"><span class="comment">//  std::string&amp;&amp; r1 = s1;           // 错误：不能绑定到左值</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> std::string&amp; r2 = s1 + s1; <span class="comment">// OK：到 const 的左值引用延长生存期</span></span><br><span class="line"><span class="comment">//  r2 += &quot;Test&quot;;                    // 错误：不能通过到 const 的引用修改</span></span><br><span class="line"> </span><br><span class="line">    std::string&amp;&amp; r3 = s1 + s1;      <span class="comment">// OK：右值引用延长生存期</span></span><br><span class="line">    r3 += <span class="string">&quot;Test&quot;</span>;                    <span class="comment">// OK：能通过到非 const 的引用修改</span></span><br><span class="line">    std::cout &lt;&lt; r3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：返回类型后置（trailing return type）</title>
      <link href="/2022/08/29/C++/C++Feature/1.4.C++11-trailing_return_type/"/>
      <url>/2022/08/29/C++/C++Feature/1.4.C++11-trailing_return_type/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auto用于占位符，真正的返回值在后面定义</span></span><br><span class="line"><span class="comment">// 返回指向 f0 的指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fp11</span><span class="params">()</span> -&gt; <span class="title">void</span><span class="params">(*)</span><span class="params">(<span class="type">const</span> std::string&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回指向 f0 的指针的函数，C++11 前的风格</span></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">fp03</span>())(<span class="type">const</span> std::string&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> f0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样的语法用于在编译时返回类型还不确定的场合</span></span><br><span class="line"><span class="comment">// 比如有模版的场合中，两个类型相加的最终类型只有运行时才能确定</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Lhs, <span class="keyword">class</span> Rhs&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">adding_func</span><span class="params">(<span class="type">const</span> Lhs &amp;lhs, <span class="type">const</span> Rhs &amp;rhs)</span> -&gt; <span class="title">decltype</span><span class="params">(lhs+rhs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs + rhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">adding_func</span>&lt;<span class="type">double</span>,<span class="type">int</span>&gt;(<span class="number">2.0</span>, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：final 和 override 说明符</title>
      <link href="/2022/08/29/C++/C++Feature/1.3.C++11-final_override/"/>
      <url>/2022/08/29/C++/C++Feature/1.3.C++11-final_override/</url>
      
        <content type="html"><![CDATA[<h2 id="final">final</h2><p>指定某个虚函数不能在派生类中被覆盖，或者某个类不能被派生。<br>在继承关系中“中途”终止派生类的重载</p><h2 id="override">override</h2><p>指定一个虚函数覆盖另一个虚函数。<br>避免重载函数名拼写错误，函数原型不匹配，重写了非虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Turing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Daaaaa</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Va</span><span class="params">(<span class="type">int</span> g)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Z</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedMid</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">D</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedTop</span> : <span class="keyword">public</span> DerivedMid &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Turing</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">//void Play() override; // error: DerivedMid 阻止派生类重载 Play()</span></span><br><span class="line">    <span class="comment">//void Daaaa() override; // error: 函数名错误</span></span><br><span class="line">    <span class="comment">//void Va(double d) override; // </span></span><br><span class="line">    <span class="comment">//void Z() override;</span></span><br><span class="line">    <span class="comment">//void Print() override;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> : Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// Base::foo 被覆盖而 A::foo 是最终覆盖函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// 错误：bar 非虚，因此它不能是 final 的</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> <span class="keyword">final</span> : A &#123; <span class="comment">// struct B 为 final</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 错误：foo 不能被覆盖，因为它在 A 中是 final 的</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : B&#123;&#125;; <span class="comment">// 错误：B 是 final 的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">// 错误：B::foo 不覆盖 A::foo</span></span><br><span class="line">                               <span class="comment">// （签名不匹配）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// OK：B::foo 覆盖 A::foo</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 错误：A::bar 非虚</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：auto 和 decltype</title>
      <link href="/2022/08/29/C++/C++Feature/1.1.C++11-auto_decltype/"/>
      <url>/2022/08/29/C++/C++Feature/1.1.C++11-auto_decltype/</url>
      
        <content type="html"><![CDATA[<h2 id="auto">auto</h2><p>对于变量，指定要从它的初始化器自动推导出它的类型。<br>C++ 11 之前 auto 是用来存储类型指示符，而 C++ 11 之后是作为一个新的类型指示符来指示编译器，auto 声明变量的类型必须由编译器在编译期间推导而得<br>auto 并非是一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译时期会将 auto 替换为变量的实际类型。</p><h2 id="decltype">decltype</h2><p>检查实体的声明类型，或表达式的类型和值类别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2.2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化复杂类型变量声明时的代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func1</span><span class="params">(std::vector&lt;std::string&gt;&amp; vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::string&gt;::iterator i = vs.<span class="built_in">begin</span>(); i &lt; vs.<span class="built_in">end</span>(); ++i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i1 = vs.<span class="built_in">begin</span>(); i1 &lt; vs.<span class="built_in">end</span>(); ++i1) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void Func2(auto x = 1) &#123;&#125; // error: auto函数参数，无法通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于结构体来说，非静态成员变量的类型不能是auto的</span></span><br><span class="line"><span class="comment">//struct str &#123; auto var = 10; &#125;; // error: auto非静态成员变量，无法通过编译</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// decltype</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">White</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Black</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decltype 编译器从左往右进行推导</span></span><br><span class="line"><span class="comment">//template&lt;typename T1, typename T2&gt;</span></span><br><span class="line"><span class="comment">//decltype( t1 + t2) Sum(T1&amp; t1, T2&amp; t2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    return t1 + t2;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(T1&amp; t1, T2&amp; t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 + t2)</span> <span class="comment">// 追踪返回类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Func1</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)i + <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Func1</span><span class="params">(<span class="type">double</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Forward</span><span class="params">(T t)</span> -&gt; <span class="title">decltype</span><span class="params">(Func1(t))</span> <span class="comment">// 可以实现参数和返回类型不同时的转发</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Func1</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// auto</span></span><br><span class="line">    <span class="keyword">auto</span> name = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">Func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">m</span> &#123; <span class="type">int</span> i; &#125; str;</span><br><span class="line">    <span class="comment">//auto str1 = str; // str1的类型是 struct m</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto声明的变量必须被初始化</span></span><br><span class="line">    <span class="comment">//auto z; // error 无法推导，编译错误</span></span><br><span class="line">    <span class="comment">//z = x;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> a&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> a1 = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//auto c[1] = &#123; 100 &#125;; // error: </span></span><br><span class="line">    <span class="comment">//vector&lt;auto&gt; vi = &#123; 1 &#125;; // error:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// decltype</span></span><br><span class="line">    White w;</span><br><span class="line">    Black b;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(w).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    White w1;</span><br><span class="line">    <span class="type">bool</span> w_b_sametype = (<span class="built_in">typeid</span>(w).<span class="built_in">hash_code</span>() == <span class="built_in">typeid</span>(b).<span class="built_in">hash_code</span>());</span><br><span class="line">    <span class="type">bool</span> w_w1_sametype = (<span class="built_in">typeid</span>(w).<span class="built_in">hash_code</span>() == <span class="built_in">typeid</span>(w1).<span class="built_in">hash_code</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w b is same type: &quot;</span> &lt;&lt; (<span class="type">int</span>)w_b_sametype &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w w1 is same type: &quot;</span> &lt;&lt; (<span class="type">int</span>)w_w1_sametype &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">decltype</span>(i) j = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(j).<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="keyword">decltype</span>(f + d) c;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vi.begin())</span> vitype</span>;</span><br><span class="line">    <span class="keyword">using</span> vitype1 = <span class="keyword">decltype</span>(vi.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">for</span> (vitype i = vi.<span class="built_in">begin</span>(); i &lt; vi.<span class="built_in">end</span>(); ++i) &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (vitype1 i = vi.<span class="built_in">begin</span>(); i &lt; vi.<span class="built_in">end</span>(); ++i) &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">decltype</span>(vi)::iterator i = vi.<span class="built_in">begin</span>(); i &lt; vi.<span class="built_in">end</span>(); ++i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Forward</span>(<span class="number">2</span>) &lt;&lt; std::endl;   <span class="comment">// Func1(int i)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Forward</span>(<span class="number">2.3</span>) &lt;&lt; std::endl; <span class="comment">// Func1(double i)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11：default 和 delete</title>
      <link href="/2022/08/29/C++/C++Feature/1.2.C++11-default_delete/"/>
      <url>/2022/08/29/C++/C++Feature/1.2.C++11-default_delete/</url>
      
        <content type="html"><![CDATA[<h2 id="defalut">defalut</h2><p>预置函数<br>显式预置的函数定义，只能用于特殊成员函数和比较运算符函数</p><blockquote><p>特殊成员函数<br>一些成员函数是特殊的：在某些环境下，即使用户不定义编译器也会定义它们。它们是：</p><ul><li>默认构造函数</li><li>复制构造函数</li><li>移动构造函数</li><li>复制赋值运算符</li><li>移动赋值运算符</li><li>析构函数</li></ul><p>特殊成员函数以及比较运算符(C++20 起)是仅有的能被预置的函数，即使用 = default 替代函数体进行定义。</p></blockquote><h2 id="delete">delete</h2><p>弃置函数<br>如果使用特殊语法 = delete ;取代函数体，那么该函数被定义为弃置的（deleted）。任何弃置函数的使用都是非良构的（程序无法编译）。这包含调用，包括显式（以函数调用运算符）及隐式（对弃置的重载运算符、特殊成员函数、分配函数等的调用），构成指向弃置函数的指针或成员指针，甚至是在不求值表达式中使用弃置函数。但是可以隐式 ODR 使用刚好被弃置的非纯虚成员函数。</p><p>如果函数被重载，那么首先进行重载决议，且只有在选择了弃置函数时程序才非良构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sometype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">sometype* p = <span class="keyword">new</span> sometype; <span class="comment">// 错误：尝试调用弃置的 sometype::operator new</span></span><br></pre></td></tr></table></figure><p>函数的弃置定义必须是翻译单元中的首条声明：已经声明过的函数不能声明为弃置的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sometype</span> &#123; <span class="built_in">sometype</span>(); &#125;;</span><br><span class="line">sometype::<span class="built_in">sometype</span>() = <span class="keyword">delete</span>; <span class="comment">// 错误：必须在首条声明弃置</span></span><br></pre></td></tr></table></figure><p>由用户提供的函数</p><p>如果一个函数由用户声明且没有在它的首个声明被显式预置或显式弃置，那么它由用户提供。由用户提供的显式预置的函数（即在它的首个声明后被显式预置）在它被显式预置的地方定义；如果该函数被隐式定义为弃置的，那么程序非良构。需要为不断变化的代码库提供稳定的二进制接口的情况下，在函数的首个定义后再声明为预置可以保证执行效率，也能提供简明的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trivial 的所有特殊成员函数都分别在它们的首个声明处被显式预置，</span></span><br><span class="line"><span class="comment">// 因此它们都不由用户提供</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">trivial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">trivial</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">trivial</span>(<span class="type">const</span> trivial&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">trivial</span>(trivial&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    trivial&amp; <span class="keyword">operator</span>=(<span class="type">const</span> trivial&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    trivial&amp; <span class="keyword">operator</span>=(trivial&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">trivial</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nontrivial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">nontrivial</span>(); <span class="comment">// 首个声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 没有在首个声明处被显式预置，</span></span><br><span class="line"><span class="comment">// 因此该函数由用户提供并在此定义</span></span><br><span class="line">nontrivial::<span class="built_in">nontrivial</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 17</title>
      <link href="/2022/08/29/C++/C++Feature/3.C++17/"/>
      <url>/2022/08/29/C++/C++Feature/3.C++17/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 20</title>
      <link href="/2022/08/29/C++/C++Feature/4.C++20/"/>
      <url>/2022/08/29/C++/C++Feature/4.C++20/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11</title>
      <link href="/2022/08/29/C++/C++Feature/1.C++11/"/>
      <url>/2022/08/29/C++/C++Feature/1.C++11/</url>
      
        <content type="html"><![CDATA[<h2 id="auto-and-decltype（占位符与-decltype-说明符）">auto and decltype（占位符与 decltype 说明符）</h2><!-- <a href="#">Post not found: _posts-subpath/文章文件名（不要后缀） 文章标题（可选）</a> --><ul><li><a href="/2022/08/29/C++/C++Feature/1.1.C++11-auto_decltype/" title="C++ 11：auto 和 decltype">C++ 11：auto 和 decltype</a></li></ul><h2 id="defaulted-and-deleted-functions（预置与弃置的函数）">defaulted and deleted functions（预置与弃置的函数）</h2><ul><li><a href="/2022/08/29/C++/C++Feature/1.2.C++11-default_delete/" title="C++ 11：default 和 delete">C++ 11：default 和 delete</a></li></ul><h2 id="final-and-override（final-说明符与-override-说明符）">final and override（final 说明符与 override 说明符）</h2><ul><li><a href="/2022/08/29/C++/C++Feature/1.3.C++11-final_override/" title="C++ 11：final 和 override 说明符">C++ 11：final 和 override 说明符</a></li></ul><h2 id="trailing-return-type（返回类型后置）">trailing return type（返回类型后置）</h2><ul><li><a href="/2022/08/29/C++/C++Feature/1.4.C++11-trailing_return_type/" title="C++ 11：返回类型后置（trailing return type）">C++ 11：返回类型后置（trailing return type）</a></li></ul><h2 id="rvalue-references（右值引用）">rvalue references（右值引用）</h2><ul><li><a href="/2022/08/29/C++/C++Feature/1.5.C++11-rvalue_references/" title="C++ 11：右值引用（rvalue references）">C++ 11：右值引用（rvalue references）</a></li></ul><h2 id="move-constructors-and-move-assignment-operators（移动构造函数与移动赋值运算符）">move constructors and move assignment operators（移动构造函数与移动赋值运算符）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.6.C++11-move_constructors/" title="C++ 11：移动构造函数（move constructors）">C++ 11：移动构造函数（move constructors）</a></li><li><a href="/2022/08/30/C++/C++Feature/1.7.C++11-move_assignment_operators/" title="C++ 11：移动赋值运算符（move assignment operators）">C++ 11：移动赋值运算符（move assignment operators）</a></li></ul><h2 id="scoped-enums（有作用域枚举）">scoped enums（有作用域枚举）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.8.C++11-scoped_enums/" title="C++ 11：有作用域枚举（scoped enums）">C++ 11：有作用域枚举（scoped enums）</a></li></ul><h2 id="constexpr-and-literal-types（常量表达式与字面类型）">constexpr and literal types（常量表达式与字面类型）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.9.C++11-constexpr/" title="C++ 11：常量表达式（constexpr）">C++ 11：常量表达式（constexpr）</a></li><li><a href="/2022/08/30/C++/C++Feature/1.10.C++11-literal_types/" title="C++ 11：字面类型（literal types）">C++ 11：字面类型（literal types）</a></li></ul><h2 id="list-initialization（初始化列表）">list initialization（初始化列表）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.11.C++11-list_initialization/" title="C++ 11：初始化列表（list initialization）">C++ 11：初始化列表（list initialization）</a></li></ul><h2 id="delegating-and-inherited-constructors（委托与继承的构造函数）">delegating and inherited constructors（委托与继承的构造函数）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.12.C++11-delegating_and_inherited_constructors/" title="C++ 11：委托与继承的构造函数 （delegating and inherited constructors）">C++ 11：委托与继承的构造函数 （delegating and inherited constructors）</a></li></ul><h2 id="brace-or-equal-initializers（花括号或等号初始化器）">brace-or-equal initializers（花括号或等号初始化器）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.13.C++11-initializers/" title="C++ 11：花括号或等号初始化器（initializers）">C++ 11：花括号或等号初始化器（initializers）</a></li></ul><h2 id="nullptr（指针字面量）">nullptr（指针字面量）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.14.C++11-nullptr/" title="C++ 11： 指针字面量（nullptr）">C++ 11： 指针字面量（nullptr）</a></li></ul><h2 id="long-long（长整型类型）">long long（长整型类型）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.15.C++11-long_long/" title="C++ 11：long long">C++ 11：long long</a></li></ul><h2 id="char16-t-and-char32-t（字符类型）">char16_t and char32_t（字符类型）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.16.C++11-char16_t_and_char32_t/" title="C++ 11：char16_t 与 char32_t（字符类型）">C++ 11：char16_t 与 char32_t（字符类型）</a></li></ul><h2 id="type-aliases（类型别名）-2">type aliases（类型别名）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.17.C++11-type_aliases/" title="C++ 11：type aliases（类型别名）">C++ 11：type aliases（类型别名）</a></li></ul><h2 id="variadic-templates（可变参数模板）">variadic templates（可变参数模板）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.18.C++11-variadic_templates/" title="C++ 11：variadic templates（可变参数模板）">C++ 11：variadic templates（可变参数模板）</a></li></ul><h2 id="generalized-non-trivial-unions（推广的（非平凡）联合体）">generalized (non-trivial) unions（推广的（非平凡）联合体）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.19.C++11-generalized_(non-trivial)_unions/" title="C++ 11：generalized (non-trivial) unions（推广的（非平凡）联合体）">C++ 11：generalized (non-trivial) unions（推广的（非平凡）联合体）</a></li></ul><h2 id="generalized-PODs-trivial-types-and-standard-layout-types-（推广的-POD-（平凡类型与标准布局类型））">generalized PODs (trivial types and standard-layout types)（推广的 POD （平凡类型与标准布局类型））</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.20.C++11-generalized_PODs/" title="C++ 11：generalized PODs (trivial types and standard-layout types)（推广的 POD （平凡类型与标准布局类型））">C++ 11：generalized PODs (trivial types and standard-layout types)（推广的 POD （平凡类型与标准布局类型））</a></li></ul><h2 id="Unicode-string-literals（Unicode-字符串字面量）">Unicode string literals（Unicode 字符串字面量）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.21.C++11-unicode_string_literals/" title="C++ 11：unicode string literals（Unicode 字符串字面量）">C++ 11：unicode string literals（Unicode 字符串字面量）</a></li></ul><h2 id="user-defined-literals（用户定义字面量）-2">user-defined literals（用户定义字面量）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.22.C++11-user-defined_literals/" title="C++ 11：user-defined literals（用户定义字面量）">C++ 11：user-defined literals（用户定义字面量）</a></li></ul><h2 id="attributes（属性）-2">attributes（属性）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.23.C++11-attributes/" title="C++ 11：attributes（属性）">C++ 11：attributes（属性）</a></li></ul><h2 id="lambda-expressions（lambda-表达式）-2">lambda expressions（lambda 表达式）</h2><ul><li><a href="/2022/08/30/C++/C++Feature/1.24.C++11-lambda_expressions/" title="C++ 11：lambda expressions（lambda 表达式）">C++ 11：lambda expressions（lambda 表达式）</a></li></ul><h2 id="noexcept-specifier-and-noexcept-operator（noexcept-说明符与-noexcept-运算符）">noexcept specifier and noexcept operator（noexcept 说明符与 noexcept 运算符）</h2><ul><li><a href="/2022/09/11/C++/C++Feature/1.25.C++11-noexcept/" title="C++ 11：noexcept">C++ 11：noexcept</a></li></ul><h2 id="alignof-and-alignas（alignof-运算符与-alignas-说明符）">alignof and alignas（alignof 运算符与 alignas 说明符）</h2><ul><li><a href="/2022/09/11/C++/C++Feature/1.26.C++11-alignof_and_alignas/" title="C++ 11：alignof 与 alignas">C++ 11：alignof 与 alignas</a></li></ul><h2 id="multithreaded-memory-model（多线程内存模型）">multithreaded memory model（多线程内存模型）</h2><ul><li><a href="/2022/09/11/C++/C++Feature/1.27.C++11-multithreaded_memory_model/" title="C++ 11：multithreaded memory model (多线程内存模型)">C++ 11：multithreaded memory model (多线程内存模型)</a></li></ul><h2 id="thread-local-storage（线程局部存储）">thread-local storage（线程局部存储）</h2><ul><li><a href="/2022/09/11/C++/C++Feature/1.28.C++11-thread_local_storage/" title="C++ 11：thread-local storage（线程局部存储）">C++ 11：thread-local storage（线程局部存储）</a></li></ul><h2 id="GC-interface-removed-in-C-23-（GC-接口）">GC interface (removed in C++23)（GC 接口）</h2><ul><li><a href="/2022/09/11/C++/C++Feature/1.29.C++11-gc_interface/" title="C++ 11：GC interface (removed in C++23)（GC 接口）">C++ 11：GC interface (removed in C++23)（GC 接口）</a></li></ul><h2 id="range-for-based-on-a-Boost-library-（范围-for（基于-Boost-库））">range-for (based on a Boost library)（范围 for（基于 Boost 库））</h2><ul><li><a href="/2022/09/11/C++/C++Feature/1.30.C++11-range-for/" title="C++ 11：range-for">C++ 11：range-for</a></li></ul><h2 id="static-assert-based-on-a-Boost-library-（static-assert（基于-Boost-库））">static_assert (based on a Boost library)（static_assert（基于 Boost 库））</h2><ul><li><a href="/2022/09/11/C++/C++Feature/1.31.C++11-static_assert/" title="C++ 11：static_assert">C++ 11：static_assert</a></li></ul><h2 id="smart-pointer（智能指针）">smart pointer（智能指针）</h2><ul><li><a href="/2022/09/13/C++/C++Feature/1.32.C++11-smart_pointer/" title="C++ 11：智能指针">C++ 11：智能指针</a></li></ul><h2 id="thread（线程）">thread（线程）</h2><ul><li><a href="/2022/09/13/C++/C++Feature/1.33.C++11-thread/" title="C++ 11：线程">C++ 11：线程</a></li></ul><h2 id="tuple">tuple</h2><ul><li><a href="/2022/09/13/C++/C++Feature/1.34.C++11-tuple/" title="C++ 11：tuple(元组)">C++ 11：tuple(元组)</a></li></ul><h2 id="chrono-lib">chrono lib</h2><p>TODO:</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 14</title>
      <link href="/2022/08/29/C++/C++Feature/2.C++14/"/>
      <url>/2022/08/29/C++/C++Feature/2.C++14/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Feature </tag>
            
            <tag> C++ 14 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 GitHub 访问不了</title>
      <link href="/2022/08/28/GitHub/0.GitHub%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86/"/>
      <url>/2022/08/28/GitHub/0.GitHub%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>访问不了 GitHub，提交代码到 GitHub 仓库也提交不了，这无疑是在我们学习编程的路上驻了一堵高墙！</p><h2 id="1-改-hosts">1. 改 hosts</h2><p>我们在浏览器输入 GitHub 的网址时，会向 DNS 服务器发送一个请求，获取到 GitHub 网站所在的服务器 IP 地址，从而进行访问。</p><p>就像你是一名快递员，在送快递前要先找中间人询问收件人的地址。而 DNS 就是这个告诉你目标地址的中间人，如果 DNS 告诉了你错误的地址、或者请求被拦截、再或者 DNS 挂了，都会导致你无法访问网站。</p><p>打开 IP 查询 <a href="https://www.ip138.com">https://www.ip138.com</a></p><p>先找到 hosts 文件的位置，不同操作系统，hosts 文件的存储位置也不同：</p><ul><li>Windows 系统：C:\Windows\System32\drivers\etc\hosts</li><li>Linux 系统：/etc/hosts</li><li>Mac（苹果电脑）系统：/etc/hosts</li></ul><p>使用管理员权限打开 hosts 文件，添加一行，将 xx 替换为你查询到的解析地址即可</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx.xx.xx.xx www.github.com</span><br></pre></td></tr></table></figure><p><img src="/assets/images/github-%E8%A7%A3%E5%86%B3%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="修改 Windows hosts"></p><p>刷新 DNS 缓存，需要以管理员权限启动命令行窗口。</p><p>这种方式比较麻烦，有时候 GitHub 的 IP 变了，就得跟着修改。</p><h2 id="2-vpn">2. vpn</h2><h2 id="3-Gitee">3. Gitee</h2><p>可以把 GitHub 上的项目导入到 Gitee。</p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt实战-获取 Windows 空闲时间</title>
      <link href="/2022/08/21/Qt/QtExamples/Qt%E5%AE%9E%E6%88%98-%E8%8E%B7%E5%8F%96Windows%E7%A9%BA%E9%97%B2%E6%97%B6%E9%97%B4/"/>
      <url>/2022/08/21/Qt/QtExamples/Qt%E5%AE%9E%E6%88%98-%E8%8E%B7%E5%8F%96Windows%E7%A9%BA%E9%97%B2%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>通过判断鼠标键盘的输入来获取 Windows 空闲时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winuser.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sysinfoapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;start do...&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;end.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLastInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        LASTINPUTINFO input;</span><br><span class="line">        <span class="type">div_t</span> iTime = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        input.cbSize = <span class="built_in">sizeof</span>(LASTINPUTINFO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetLastInputInfo</span>(&amp;input)) &#123;</span><br><span class="line">            iTime = <span class="built_in">div</span>((<span class="built_in">GetTickCount</span>() - input.dwTime), <span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; iTime.quot;</span><br><span class="line">            <span class="keyword">if</span> (iTime.quot &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="built_in">DoSomething</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用子线程获取系统空闲时间，并在一定时间后做一些事情</span></span><br><span class="line">    std::<span class="built_in">thread</span>([]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;start thread: PrintLastInput...&quot;</span>;</span><br><span class="line">        <span class="built_in">PrintLastInput</span>();</span><br><span class="line">    <span class="comment">//&#125;).join(); // 立刻执行线程</span></span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 从 thread 对象分离执行线程，允许执行独立地持续。</span></span><br><span class="line">    <span class="comment">// 一旦该线程退出，则释放任何分配的资源。</span></span><br><span class="line">    <span class="comment">// 调用 detach 后 *this 不再占有任何线程。 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;sleep...&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> QtExamples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtExamples </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2019 编译调试火狐浏览器源码</title>
      <link href="/2022/08/05/OpenSourceProjects/Firefox/VS2019%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BA%90%E7%A0%81/"/>
      <url>/2022/08/05/OpenSourceProjects/Firefox/VS2019%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="官方提供的编译文档">官方提供的编译文档</h2><blockquote><p>注意：官方提供的编译文档会更新，以下方法可能不适用于最新的源码编译方式</p></blockquote><p><a href="https://firefox-source-docs.mozilla.org/setup/windows_build.html">在Windows上构建Firefox</a><br><a href="https://firefox-source-docs.mozilla.org/build/buildsystem/visualstudio.html#visual-studio-projects">Visual Studio项目</a></p><h2 id="前期准备">前期准备</h2><ul><li>安装 <a href="https://visualstudio.microsoft.com/zh-hans/downloads/">Visual Studio</a></li><li>安装 <a href="https://www.rust-lang.org/zh-CN/tools/install">Rust</a></li><li>安装 <a href="https://ftp.mozilla.org/pub/mozilla.org/mozilla/libraries/win32/MozillaBuildSetup-Latest.exe">MozillaBuild</a></li></ul><h3 id="安装Rust">安装Rust</h3><p><img src="/assets/images/mozilla-build-8.png" alt="rust"><br><img src="/assets/images/mozilla-build-7.png" alt="rust version"></p><h3 id="启动shell">启动shell</h3><p>在安装完成MozillaBuild后启动start-shell.bat，以后的操作都将会在启动的shell中进行。</p><p><img src="/assets/images/mozilla-build-5.png" alt="start-shell.bat"></p><h2 id="在线下载源码">在线下载源码</h2><p>在shell中打开到指定的目录</p><p><img src="/assets/images/mozilla-build-6.png" alt="open source dir"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">$ hg <span class="built_in">clone</span> https://hg.mozilla.org/mozilla-central</span></span><br></pre></td></tr></table></figure><p>如果遇到shell请求输入，一路 y 下去就行了</p><h2 id="配置编译源码">配置编译源码</h2><blockquote><p>$ mach bootstrap</p><p>Please choose the version of Firefox you want to build:</p><ol><li>Firefox for Desktop Artifact Mode</li><li>Firefox for Desktop</li><li>GeckoView/Firefox for Android Artifact Mode</li><li>GeckoView/Firefox for Android</li></ol></blockquote><p>这里输入 2</p><p>重启 shell（start-shell.bat ），并打开到源码目录</p><p>执行配置</p><blockquote><p>$ mach configure</p></blockquote><p>使用VisualStudio作为编译工具</p><blockquote><p>$ mach build-backend -b VisualStudio</p></blockquote><p>生成解决方案（.sln）目录如下：</p><p><img src="/assets/images/mozilla-build-9.png" alt="sln"></p><h2 id="使用VS2019编译源码">使用VS2019编译源码</h2><p>打开mozilla.sln</p><p><img src="/assets/images/mozilla-build-3.png" alt="mozilla vs"></p><p>生成解决方案，经过一两个小时即可得到编译文件：</p><p><img src="/assets/images/mozilla-build-10.png" alt="bin"></p><h2 id="调试">调试</h2><p>把<code>firefox.exe</code>项设置为启动项，按<code>F5</code>开始调试：</p><p><img src="/assets/images/mozilla-build-11.png" alt="debuging"></p><p>如果不知道程序入口在哪里，试试<code>F10</code>进入单步执行</p><p><img src="/assets/images/mozilla-build-12.png" alt="debuging"></p><p>程序入口</p><p><img src="/assets/images/mozilla-build-13.png" alt="debuging"></p><h3 id="调试窗口拖放">调试窗口拖放</h3><p>从程序入口调试，却找不到创建主窗口的代码</p><p><img src="/assets/images/mozilla-build-19.png" alt="debuging"></p><p>把firefox.exe附加到进程中</p><p><img src="/assets/images/mozilla-build-16.png" alt="debuging"><br><img src="/assets/images/mozilla-build-17.png" alt="debuging"></p><p>部分断点位置</p><p><img src="/assets/images/mozilla-build-14.png" alt="debuging"><br><img src="/assets/images/mozilla-build-15.png" alt="debuging"></p><p>如果遇到卡住了，那么如下图操作，然后重新启动调试-&gt;附加进程</p><p><img src="/assets/images/mozilla-build-18.png" alt="debuging"></p>]]></content>
      
      
      <categories>
          
          <category> Firefox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Firefox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VLC源码分析-新知识</title>
      <link href="/2022/07/04/OpenSourceProjects/VLC/%E6%96%B0%E7%9F%A5%E8%AF%86-VLC/"/>
      <url>/2022/07/04/OpenSourceProjects/VLC/%E6%96%B0%E7%9F%A5%E8%AF%86-VLC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过 VLC Media Player 开源项目了解到一些自己未知的知识。</p></blockquote><ul><li>1.GNU gettext 为程序的国际化i18n和本地化l10n提供了很好的支持。 <a href="https://www.gnu.org/software/gettext/">https://www.gnu.org/software/gettext/</a><br>可以使用文本编辑或POedit来修改.po文件，添加相应的翻译语句。 <a href="https://github.com/vslavik/poedit">https://github.com/vslavik/poedit</a><blockquote><p>TODO: 编写文章介绍、了解如何使用及代码例子</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> vlc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> vlc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VLC 源码分析：VS2013 编译 VLC 源码</title>
      <link href="/2022/07/04/OpenSourceProjects/VLC/VLC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-VS2013%E7%BC%96%E8%AF%91VLC%E6%BA%90%E7%A0%81/"/>
      <url>/2022/07/04/OpenSourceProjects/VLC/VLC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-VS2013%E7%BC%96%E8%AF%91VLC%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前提准备">前提准备</h2><p>在 GitHub 上有人已经弄好可以使用 VS 2013 编译 vlc-2.2.6.32 版本的代码<br><a href="https://github.com/sunqueen/vlc-2.2.6.32-2013">https://github.com/sunqueen/vlc-2.2.6.32-2013</a></p><p>所以，这就要安装 vs2013_update4（可以到 <a href="https://msdn.itellyou.cn/">i tell you</a> 下载，这里提供我下载的 <a href="ed2k://%7Cfile%7Ccn_visual_studio_professional_2013_with_update_4_x86_dvd_5935706.iso%7C7557046272%7C4B201FA2D6B219ADE84E2398535D7389%7C/">ed2k</a> ）<br><img src="/assets/images/vs2013_update4.png" alt="vs2013_update4"></p><p>Windows 10 最新 SDK</p><h2 id="编译-调试">编译 &amp; 调试</h2><p><img src="/assets/images/vlc-WinMain.png" alt="vlc-WinMain"></p><p><img src="/assets/images/vlc-run.png" alt="vlc-run"></p>]]></content>
      
      
      <categories>
          
          <category> vlc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> vlc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tiled 源码分析：编译</title>
      <link href="/2022/07/04/OpenSourceProjects/Tiled/Tiled-1-%E7%BC%96%E8%AF%91/"/>
      <url>/2022/07/04/OpenSourceProjects/Tiled/Tiled-1-%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>Tiled 是一个 2D 级别的编辑器，可帮助您开发游戏内容。它的主要功能是编辑各种形式的平铺地图，但它也支持免费的图像放置以及功能强大的方式来注释游戏使用的额外信息的水平。<br><a href="https://doc.mapeditor.org/en/stable/manual/introduction/#getting-started">Tiled-introduction</a></p><p><img src="/assets/images/Tiled.png" alt="Tiled"></p><h2 id="源码">源码</h2><p><a href="https://github.com/mapeditor/tiled">github-tiled</a></p><h2 id="编译">编译</h2><p>使用 QtCreator 打开 <code>tiled.qbs</code> Build &amp; Run<br><img src="/assets/images/Tiled-build.png" alt="Tiled-build"></p>]]></content>
      
      
      <categories>
          
          <category> Tiled </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Tiled </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VLC 源码分析：序</title>
      <link href="/2022/07/04/OpenSourceProjects/VLC/VLC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-0-%E5%BA%8F/"/>
      <url>/2022/07/04/OpenSourceProjects/VLC/VLC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-0-%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>为了了解 VLC Media Player 如何使用 Qt 创建 UI</p>]]></content>
      
      
      <categories>
          
          <category> vlc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> vlc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 编译器介绍</title>
      <link href="/2022/06/14/C++/C++%20%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/06/14/C++/C++%20%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC（GNU-Compiler-Collection）">GCC（GNU Compiler Collection）</h2><p>官方网站: <a href="https://gcc.gnu.org">https://gcc.gnu.org</a></p><p>GCC 有 Windows 移植版本，比较出名的就是 MinGW 和 TDM-GCC。</p><p>GNU 编译器套件（GNU Compiler Collection）包括 C、C++、Objective-C、Fortran、Java、Ada 和 Go 语言的前端，也包括了这些语言的库（如 libstdc++、libgcj 等等）。GCC 的初衷是为 GNU 操作系统专门编写的一款编译器。GNU 系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。</p><h2 id="llvm-Clang">llvm+Clang</h2><p>LLVM 官方网站：<a href="http://llvm.org">http://llvm.org</a></p><p>Clang 官方网站：<a href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></p><p>LLVM 是构架编译器(compiler)的框架系统，以 C++编 写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。LLVM 计划启动于 2000 年，最初由 University of Illinois at Urbana-Champaign 的 Chris Lattner 主持开展。2006 年 Chris Lattner 加盟 Apple Inc，并致力于 LLVM 在 Apple 开发体系中的应用。Apple 也是 LLVM 计划的主要资助者。</p><p>Low Level Virtual Machine (LLVM) 是一个开源的编译器架构，它已经被成功应用到多个应用领域。Clang 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 以及 Objective-C++ 等编程语言。Clang 对源程序进行词法分析和语义分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为后端代码的生成器。</p><p>Clang 的开发目标是提供一个可以替代 GCC 的前端编译器。与 GCC 相比，Clang 是一个重新设计的编译器前端，具有一系列优点，例如模块化，代码简单易懂，占用内存小以及容易扩展和重用等。由于 Clang 在设计上的优异性，使得 Clang 非常适合用于设计源代码级别的分析和转化工具。Clang 也已经被应用到一些重要的开发领域，如 Static Analysis 是一个基于 Clang 的静态代码分析工具。</p><h2 id="Watcom-C-C">Watcom C/C++</h2><p>官方网站：<a href="http://www.openwatcom.org/index.php/Download">http://www.openwatcom.org/index.php/Download</a></p><p>在 DOS 开发环境中，Watcom C/C++ 编译器 以编译后的 exe 运行高速而著称，且首个支持 Intel 80386 &quot;保护模式&quot;的编译器。于 90 年代中期，大批的雄心技术游戏(例如 Doom、Descent、Duke Nukem 3D 都以 Watcom C 写成）</p><p>Watcom C/C++ 编译器、Watch Fortran 编译器 经已在不其先前所属公司 Sybase 售卖, 而被 SciTech 软件公司 作为 Open Watcom 开源包 发行。类似于其他的 开源编译器(例如 [GCC])项目，Watcom C 代码小而便携, 其编译器后端(代码生成器)的目标码可变。该编译器可在 DOS、OS/2、Windows 等操作系统上运行，并生成各种可运行的(不必是该操作系统的)代码。该编译器支持Novell NetWare 的 NLM 目标码。目前正进行 为 Linux[1] 、modern BSD (例如FreeBSD) 操作系统 重定目标码, 以便在 x86、PowerPC 及　其它处理器上运行。Open Watcom C/C++ 的 1.4 版于 2005 年 12 月发行，采用 Linux x86 为实验目标, 支持 NT、OS/2 等 host 平台. 曾有某被弃置的 QNX 版本，但其编译所须的库并未开源发行。当前最近的稳定版是 1.9 版，在 2010 年 6 月发行。</p><h2 id="Digital-Mars">Digital Mars</h2><p>官方网站：<a href="http://www.digitalmars.com">http://www.digitalmars.com</a></p><p>DigitalMars 是一款高性能的编译器，功能包含，快速编译/链接时、强大的优化技术、Contract 设计、完整的资源库、浏览 HTML 文档，反汇编、库、资源编译器等。命令行及 GUI 版本、教程、代码示例、在线更新、标准模板库等等。</p><h2 id="MSVC系列">MSVC系列</h2><p>与 Visual Studio 集成发布，微软自己的编译器，VS  是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如 UML 工具、代码管控工具、集成开发环境（IDE）等等。所写的目标代码适用于微软支持的所有平台，包括 Microsoft Windows、Windows Mobile、Windows CE、.NET Framework、.NET Compact Framework 和 Microsoft Silverlight 及 Windows Phone。</p><h2 id="Borland系列（turbo-c和Borland-C-）">Borland系列（turbo c和Borland C++）</h2><p>Borland C++ Builder Compiler 是一个 BC 编译器。它是用来优化 BC 开发系统的工具。它包括最后版本的 ANSI/ISO C++ 语言的支持，包括 RTL，C++ 的 STL 框架结构支持。Turbo C（TC）是其早期的命令行编译器作品</p><h2 id="Intel-C">Intel C++</h2><p>Intel C++ Compiler （简称 icc 或 icl）是美国 Intel 公司开发的 C/C++ 编译器，适用于 Linux、Microsoft Windows 和 Mac OS X 操作系统。</p><p>Intel 编译支持 IA-32、Intel 64、Itanium 2、Intel Atom 处理器和某些非 Intel 的兼容处理器（例如某些 AMD 处理器）。开发人员应当检查系统需求。适用于 IA-32 和 Intel 64 的 Intel C++ 编译器的主要特点是自动向量化器，它能够生成 SSE、SSE2 和 SSE3 的 SIMD 指令及其适用于 Intel 无线 MMX 和 MMX 2 的嵌入式变种。</p><p>Intel C++ Compiler 进一步支持 OpenMP 3.0 和适用于对称多处理的自动并行化。借助于 Cluster OpenMP 的附加能力，编译器还可为分布存储多处理根据 OpenMP 指示自动生成消息传递接口调用。</p><p>Intel C++ Compiler 可通过四种方式获得，它分别是 Intel Parallel Studio、Intel C++ Compiler 专业版、Intel 编译器套装和 Intel Cluster Toolkit 编译器版的一部分。该编译器的最新发布是 Intel C++ Compiler 14.0 版本</p><h2 id="TCC-Tiny-C-Compiler">TCC(Tiny C Compiler)</h2><p>官方网站：<a href="http://bellard.org/tcc">http://bellard.org/tcc</a></p><p>Tiny C Compiler（缩写为 TCC, tCc 或 TinyCC）用于 x86（16/32位）或是 x86-64（64位）系统的 C compiler，而开发者为 Fabrice Bellard。软件是设计用于低级电脑环境，或是于磁盘容量有限的空间中（1.44 磁片或是硬盘）。软件可以适用于 Windows、Linux、Unix 操作系统，而最新版本为 0.9.26（Feb 15, 2013）。TCC 是在 GNU 宽通用公共许可证（LGPL）协议规范下发布。作者是大神法布里斯·贝拉（FabriceBellard）。</p><p>TCC符合ANSI C（C89/C90）规范，Tiny C Compiler Reference Documentation accessed on 2008-08-07 亦符合新版的 ISO C99 标准规范，与 GNU C 扩展的内嵌汇编语言（即 inline assembler，内联汇编大陆用语）功能汇编语言。</p><p>而 Google Andriod 系统内亦曾经内置于其中，于 Andriod 2.0 版本中。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt实战-Qt SendMessage 进程通信</title>
      <link href="/2022/05/24/Qt/QtExamples/Qt%E5%AE%9E%E6%88%98-QtSendMessage%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/05/24/Qt/QtExamples/Qt%E5%AE%9E%E6%88%98-QtSendMessage%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="名词解释">名词解释</h2><p>PostMessage 是 Windows API(应用程序接口) 中的一个常用函数，用于将一条消息放入到消息队列中。并且不会等待响应的线程处理消息，而是直接返回。（简单的理解就是异步）。</p><p>而 SendMessage 作用一样，但是会等待结果返回（同步）</p><p>我们先来看 PostMessag 函数的原型：</p><p>hWnd：其窗口程序接收消息的窗口的句柄。可取有特定含义的两个值：</p><p>HWND_BROADCAST：消息被寄送到系统的所有顶层窗口，包括无效或不可见的非自身拥有的窗口、 被覆盖的窗口和弹出式窗口。消息不被寄送到子窗口</p><p>NULL：此函数的操作和调用参数 dwThread 设置为当前线程的标识符 PostThreadMessage 函数一样</p><p>Msg：指定被寄送的消息。</p><p>wParam：指定附加的消息特定的信息。</p><p>LParam：指定附加的消息特定的信息。</p><p>返回值：如果函数调用成功，返回非零，否则函数调用返回值为零</p><p>接收的时候，使用 QT5 中的方法是 在接收的类中，重新实现 nativeEvent 函数（Qt4的时候使用的是 winEvent,从 Qt5 开始，就使用 nativeEvent ）,这个方法既可以拦截系统消息，也可以拦截通过 postMessage,sendMessage 发送的自定义消息。</p><h2 id="例子">例子</h2><p>需求：要求程序 A 以 tab 标签形式嵌套到程序 B 中</p><p>部分核心代码</p><p>嵌套</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> window = QWindow::<span class="built_in">fromWinId</span>((WId)hwnd);</span><br><span class="line"><span class="keyword">if</span> (window) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;createWindowContainer.............&quot;</span>;</span><br><span class="line">    window-&gt;<span class="built_in">setFlags</span>(window-&gt;<span class="built_in">flags</span>() | Qt::CustomizeWindowHint | Qt::WindowTitleHint);</span><br><span class="line">    QWidget *containerWidget = <span class="keyword">new</span> QWidget;</span><br><span class="line">    containerWidget-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;containerWidget&quot;</span>);</span><br><span class="line">    containerWidget-&gt;<span class="built_in">setProperty</span>(<span class="string">&quot;processID&quot;</span>, processID);</span><br><span class="line">    containerWidget-&gt;<span class="built_in">setProperty</span>(<span class="string">&quot;winID&quot;</span>, jsObj.<span class="built_in">value</span>(<span class="string">&quot;winId&quot;</span>).<span class="built_in">toString</span>());</span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(containerWidget);</span><br><span class="line">    layout-&gt;<span class="built_in">setMargin</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> w = QWidget::<span class="built_in">createWindowContainer</span>(window, containerWidget, Qt::Widget))</span><br><span class="line">        layout-&gt;<span class="built_in">addWidget</span>(w);</span><br><span class="line">    containerWidget-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    mw-&gt;<span class="built_in">addTabPage</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/resource/images/qd.ico&quot;</span>), title, containerWidget);</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">MoveWindow</span>(hwnd, mw-&gt;<span class="built_in">stackedWidget</span>()-&gt;<span class="built_in">x</span>(), mw-&gt;<span class="built_in">stackedWidget</span>()-&gt;<span class="built_in">y</span>(), mw-&gt;<span class="built_in">stackedWidget</span>()-&gt;<span class="built_in">width</span>(), mw-&gt;<span class="built_in">stackedWidget</span>()-&gt;<span class="built_in">height</span>(), <span class="literal">true</span>);</span><br><span class="line">    mw-&gt;<span class="built_in">raise</span>();</span><br><span class="line"></span><br><span class="line">    QApplication::<span class="built_in">processEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MainWindow::addTabPage</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text, QWidget *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insertTabPage</span>(ui-&gt;tabBar-&gt;<span class="built_in">count</span>(), icon, text, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MainWindow::insertTabPage</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QString &amp;text, QWidget *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;stackedWidget-&gt;<span class="built_in">insertWidget</span>(index, w);</span><br><span class="line">    <span class="type">int</span> ret = ui-&gt;tabBar-&gt;<span class="built_in">insertTab</span>(index, text);</span><br><span class="line">    ui-&gt;tabBar-&gt;<span class="built_in">setTabIcon</span>(index, icon);</span><br><span class="line">    ui-&gt;tabBar-&gt;<span class="built_in">setCurrentIndex</span>(index);</span><br><span class="line">    ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(index);</span><br><span class="line"></span><br><span class="line">    m_flh-&gt;<span class="built_in">addExcludeItem</span>(ui-&gt;tabBar-&gt;<span class="built_in">tabButton</span>(ret, QTabBar::ButtonPosition::RightSide));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序 A 发送 Windows 消息给程序 B</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::sendWindowMsgToQDMaster</span><span class="params">(<span class="type">const</span> QString &amp;winID, <span class="type">const</span> QByteArray &amp;msgData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> strWinId = winID.<span class="built_in">toULongLong</span>(&amp;ok);</span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">&quot;winid error!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">reinterpret_cast</span>&lt;HWND&gt;(strWinId);</span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">GetLastErrorAsString1</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">IsWindow</span>(hwnd)) &#123;</span><br><span class="line">        <span class="comment">// 单独启动一个线程进行数据传递</span></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([=]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 使用 COPYDATA 的方式进行数据传递</span></span></span></span><br><span class="line"><span class="params"><span class="function">            COPYDATASTRUCT copyData;</span></span></span><br><span class="line"><span class="params"><span class="function">            copyData.dwData = CUSTOM_TYPE_YDPLATFORM;</span></span></span><br><span class="line"><span class="params"><span class="function">            copyData.lpData = (PVOID)msgData.data();</span></span></span><br><span class="line"><span class="params"><span class="function">            copyData.cbData = (DWORD)msgData.size();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            HWND sender = (HWND)effectiveWinId();</span></span></span><br><span class="line"><span class="params"><span class="function">            LRESULT result = ::SendMessageW(hwnd, WM_COPYDATA, <span class="keyword">reinterpret_cast</span>&lt;WPARAM&gt;(sender), <span class="keyword">reinterpret_cast</span>&lt;LPARAM&gt;(&amp;copyData));</span></span></span><br><span class="line"><span class="params"><span class="function">            qDebug() &lt;&lt; __FUNCTION__ &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">        <span class="comment">// 分离子线程（数据传递线程）与主线程（UI 线程）</span></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;findwindow failed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收 Windows 消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::nativeEvent</span><span class="params">(<span class="type">const</span> QByteArray &amp;eventType, <span class="type">void</span> *message, <span class="type">long</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(eventType);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">    MSG *msg = <span class="built_in">static_cast</span>&lt;MSG *&gt;(message);</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_COPYDATA: &#123;</span><br><span class="line">        COPYDATASTRUCT *copyData = <span class="built_in">reinterpret_cast</span>&lt;COPYDATASTRUCT*&gt;(msg-&gt;lParam);</span><br><span class="line">        <span class="keyword">if</span> (copyData-&gt;dwData == CUSTOM_TYPE_YDPLATFORM) &#123;</span><br><span class="line"></span><br><span class="line">            QString structMsg = QString::<span class="built_in">fromUtf8</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(copyData-&gt;lpData), copyData-&gt;cbData);</span><br><span class="line"><span class="comment">//            qDebug() &lt;&lt; &quot;CUSTOM_TYPE_YDPLATFORM receive msg: &quot; &lt;&lt; structMsg;</span></span><br><span class="line">            <span class="built_in">parseCustomMsgCommand</span>(structMsg);</span><br><span class="line"></span><br><span class="line">            *result = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// Q_OS_WIN</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> QtExamples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtExamples </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt问题-namespace</title>
      <link href="/2022/05/19/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-namespace/"/>
      <url>/2022/05/19/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-namespace/</url>
      
        <content type="html"><![CDATA[<h2 id="Namespace-declaration-lacks-Q-NAMESPACE-macro">Namespace declaration lacks Q_NAMESPACE macro</h2><p>Qt 5.15+ 发现这个问题，Qt 5.9 ~ Qt 5.12 都没有这个问题</p><p><a href="https://bugreports.qt.io/browse/QTBUG-68611">https://bugreports.qt.io/browse/QTBUG-68611</a></p><h2 id="解决方案">解决方案</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> E &#123; </span><br><span class="line">  Q_NAMESPACE </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> QtProblems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtProblems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tdesktop 窗口贴图</title>
      <link href="/2022/04/24/OpenSourceProjects/tdesktop/tdesktop-2-%E7%AA%97%E5%8F%A3%E8%B4%B4%E5%9B%BE/"/>
      <url>/2022/04/24/OpenSourceProjects/tdesktop/tdesktop-2-%E7%AA%97%E5%8F%A3%E8%B4%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/images/tdesktop-startwidget-paint.png" alt="tdesktop-startwidget-paint"></p>]]></content>
      
      
      <categories>
          
          <category> tdesktop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> tdesktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt问题-序</title>
      <link href="/2022/04/22/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-%E5%BA%8F/"/>
      <url>/2022/04/22/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>记录在使用 Qt 过程中遇到的一些问题及解决办法。</p>]]></content>
      
      
      <categories>
          
          <category> QtProblems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtProblems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt问题-指针变量传参问题</title>
      <link href="/2022/04/22/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/22/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题1：在操作过程中指针被释放了">问题1：在操作过程中指针被释放了</h2><p><code>QTreeWidgetItem *treeItem = treeWidget-&gt;currentItem();</code> 被别的类保存了一份（比如一个表格渲染任务保存了当前渲染的 treeItem），在渲染完成后还想要对 treeItem 做一些别的操作，此时 treeWidget 由于某些原因或操作被重新加载了（treeItem 被清除了），但是当前渲染的 treeItem 还要操作（比如获取数据 treeItem.data(xx) data(xx) 内部的某些变量地址就会显示 0xffffffffffxxxxxx）就会引起程序崩溃。</p><p><img src="/assets/images/QtProblems-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98.png" alt="QtProblems-指针变量传参问题"></p><h3 id="指针变量传参问题-测试例子">指针变量传参问题-测试例子</h3><p><img src="/assets/images/QtProblems-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98-%E6%B5%8B%E8%AF%95%E4%BE%8B%E5%AD%90.png" alt="QtProblems-指针变量传参问题-测试例子"></p><p>操作顺序：btn1 -&gt; btn2 -&gt; btn1 -&gt; btn3</p><p>当再次按下 btn1 后，重新加载树控件数据，此时 m_item 已经被释放了。<br>btn3 操作里用到了已经被释放的 m_item，从而引起程序崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> QtProblems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtProblems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt实战-获取文本宽高画框</title>
      <link href="/2022/04/21/Qt/QtExamples/Qt%E5%AE%9E%E6%88%98-%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%AE%BD%E9%AB%98%E7%94%BB%E6%A1%86/"/>
      <url>/2022/04/21/Qt/QtExamples/Qt%E5%AE%9E%E6%88%98-%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%AE%BD%E9%AB%98%E7%94%BB%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Label::paintEvent</span><span class="params">(QPaintEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    QFont font = painter.<span class="built_in">font</span>();</span><br><span class="line">    font.<span class="built_in">setPixelSize</span>(<span class="number">24</span>);</span><br><span class="line">    painter.<span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">20</span>), <span class="built_in">tr</span>(<span class="string">&quot;HelloHello&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> QRect rectangle = <span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">    QRect boundingRect;</span><br><span class="line">    painter.<span class="built_in">drawText</span>(rectangle, <span class="number">0</span>, <span class="built_in">tr</span>(<span class="string">&quot;HelloHello&quot;</span>), &amp;boundingRect);</span><br><span class="line"></span><br><span class="line">    QPen pen = painter.<span class="built_in">pen</span>();</span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::DotLine);</span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::red);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(boundingRect.<span class="built_in">adjusted</span>(<span class="number">0</span>, <span class="number">0</span>, -pen.<span class="built_in">width</span>(), -pen.<span class="built_in">width</span>()));</span><br><span class="line"></span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::DashLine);</span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::green);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(rectangle.<span class="built_in">adjusted</span>(<span class="number">0</span>, <span class="number">0</span>, -pen.<span class="built_in">width</span>(), -pen.<span class="built_in">width</span>()));</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;boundingRect1:&quot;</span>&lt;&lt; boundingRect;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">restore</span>();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">        painter.<span class="built_in">setFont</span>(font);</span><br><span class="line"></span><br><span class="line">        painter.<span class="built_in">drawText</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">120</span>), <span class="built_in">tr</span>(<span class="string">&quot;HelloHello&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> QRect rectangle = <span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">130</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">        QRect boundingRect;</span><br><span class="line">        painter.<span class="built_in">drawText</span>(rectangle, <span class="number">0</span>, <span class="built_in">tr</span>(<span class="string">&quot;HelloHello&quot;</span>), &amp;boundingRect);</span><br><span class="line"></span><br><span class="line">        QPen pen = painter.<span class="built_in">pen</span>();</span><br><span class="line">        pen.<span class="built_in">setStyle</span>(Qt::DotLine);</span><br><span class="line">        pen.<span class="built_in">setColor</span>(Qt::red);</span><br><span class="line">        painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">        painter.<span class="built_in">drawRect</span>(boundingRect.<span class="built_in">adjusted</span>(<span class="number">0</span>, <span class="number">0</span>, -pen.<span class="built_in">width</span>(), -pen.<span class="built_in">width</span>()));</span><br><span class="line"></span><br><span class="line">        pen.<span class="built_in">setStyle</span>(Qt::DashLine);</span><br><span class="line">        pen.<span class="built_in">setColor</span>(Qt::green);</span><br><span class="line">        painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">        painter.<span class="built_in">drawRect</span>(rectangle.<span class="built_in">adjusted</span>(<span class="number">0</span>, <span class="number">0</span>, -pen.<span class="built_in">width</span>(), -pen.<span class="built_in">width</span>()));</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;boundingRect2:&quot;</span>&lt;&lt; boundingRect;</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/images/QtExamples-DrawByTextRect.png" alt="QtExamples-DrawByTextRect"></p>]]></content>
      
      
      <categories>
          
          <category> QtExamples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtExamples </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt实战-数字提示</title>
      <link href="/2022/04/21/Qt/QtExamples/Qt%E5%AE%9E%E6%88%98-%E6%95%B0%E5%AD%97%E6%8F%90%E7%A4%BA/"/>
      <url>/2022/04/21/Qt/QtExamples/Qt%E5%AE%9E%E6%88%98-%E6%95%B0%E5%AD%97%E6%8F%90%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="数字提示-圆角矩形">数字提示(圆角矩形)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Label::paintEvent</span><span class="params">(QPaintEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> qreal radius = <span class="number">10</span>;</span><br><span class="line">    QRectF rect = <span class="built_in">QRect</span>(<span class="number">10</span>, <span class="number">200</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.<span class="built_in">moveTo</span>(rect.<span class="built_in">bottomRight</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">    path.<span class="built_in">lineTo</span>(rect.<span class="built_in">topRight</span>() + <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">    path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rect.<span class="built_in">topRight</span>() - <span class="built_in">QPointF</span>(radius * <span class="number">2</span>, <span class="number">0</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius *<span class="number">2</span>)), <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">    path.<span class="built_in">lineTo</span>(rect.<span class="built_in">topLeft</span>() + <span class="built_in">QPointF</span>(radius, <span class="number">0</span>));</span><br><span class="line">    path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rect.<span class="built_in">topLeft</span>()), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line">    path.<span class="built_in">lineTo</span>(rect.<span class="built_in">bottomLeft</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">    path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rect.<span class="built_in">bottomLeft</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius * <span class="number">2</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">180</span>, <span class="number">90</span>);</span><br><span class="line">    path.<span class="built_in">lineTo</span>(rect.<span class="built_in">bottomLeft</span>() + <span class="built_in">QPointF</span>(radius, <span class="number">0</span>));</span><br><span class="line">    path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rect.<span class="built_in">bottomRight</span>() - <span class="built_in">QPointF</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">270</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">fillPath</span>(path, <span class="built_in">QColor</span>(Qt::red));</span><br><span class="line"></span><br><span class="line">    QPen pen = painter.<span class="built_in">pen</span>();</span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::white);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(rect, Qt::AlignCenter, QString::<span class="built_in">number</span>(<span class="number">99</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        painter.<span class="built_in">save</span>();</span><br><span class="line">        <span class="type">const</span> qreal radius = <span class="number">10</span>;</span><br><span class="line">        QRectF rect = <span class="built_in">QRect</span>(<span class="number">50</span>, <span class="number">200</span>, <span class="number">50</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        QPainterPath path;</span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">moveTo</span>(rect.<span class="built_in">bottomRight</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">        path.<span class="built_in">lineTo</span>(rect.<span class="built_in">topRight</span>() + <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">        path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rect.<span class="built_in">topRight</span>() - <span class="built_in">QPointF</span>(radius * <span class="number">2</span>, <span class="number">0</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius *<span class="number">2</span>)), <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">        path.<span class="built_in">lineTo</span>(rect.<span class="built_in">topLeft</span>() + <span class="built_in">QPointF</span>(radius, <span class="number">0</span>));</span><br><span class="line">        path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rect.<span class="built_in">topLeft</span>()), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line">        path.<span class="built_in">lineTo</span>(rect.<span class="built_in">bottomLeft</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">        path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rect.<span class="built_in">bottomLeft</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius * <span class="number">2</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">180</span>, <span class="number">90</span>);</span><br><span class="line">        path.<span class="built_in">lineTo</span>(rect.<span class="built_in">bottomLeft</span>() + <span class="built_in">QPointF</span>(radius, <span class="number">0</span>));</span><br><span class="line">        path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rect.<span class="built_in">bottomRight</span>() - <span class="built_in">QPointF</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">270</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">        painter.<span class="built_in">fillPath</span>(path, <span class="built_in">QColor</span>(Qt::red));</span><br><span class="line"></span><br><span class="line">        QPen pen = painter.<span class="built_in">pen</span>();</span><br><span class="line">        pen.<span class="built_in">setColor</span>(Qt::white);</span><br><span class="line">        painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">        painter.<span class="built_in">drawText</span>(rect, Qt::AlignCenter, QString::<span class="built_in">number</span>(<span class="number">9999999</span>));</span><br><span class="line">        painter.<span class="built_in">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/images/QtExamples-NumTip.png" alt="QtExamples-NumTip"></p><h2 id="文本后面添加数字提示">文本后面添加数字提示</h2><p>需求：树形结构的每一项的文本后面添加数字提示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// paint</span></span><br><span class="line"><span class="type">int</span> leftMargin = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> widthNumTip = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> heightNumTip = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> xNumTip = r.<span class="built_in">width</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = m_manager ? m_manager-&gt;<span class="built_in">getNumTip</span>(index) : <span class="built_in">getNumTip</span>(index);</span><br><span class="line"><span class="keyword">auto</span> numTipVisible = m_manager ? m_manager-&gt;<span class="built_in">isNumTipVisible</span>(num) : <span class="built_in">isNumTipVisible</span>(num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numTipVisible) &#123;</span><br><span class="line">    <span class="comment">// 根据数字的位数计算圆角矩形的宽度</span></span><br><span class="line">    widthNumTip += <span class="number">3</span> * QString::<span class="built_in">number</span>(num).<span class="built_in">length</span>();</span><br><span class="line">    </span><br><span class="line">    xNumTip = r.<span class="built_in">width</span>() - widthNumTip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QFontMetrics fm = painter-&gt;<span class="built_in">fontMetrics</span>();</span><br><span class="line">flags = Qt::AlignLeft | Qt::AlignVCenter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> textWidth = fm.<span class="built_in">width</span>(text);</span><br><span class="line"><span class="keyword">if</span> (textWidth &lt; xNumTip) &#123;</span><br><span class="line">    xNumTip = textWidth;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    text = fm.<span class="built_in">elidedText</span>(text, Qt::ElideRight, numTipVisible ? r.<span class="built_in">width</span>() - widthNumTip : r.<span class="built_in">width</span>(), Qt::TextShowMnemonic);</span><br><span class="line">&#125;</span><br><span class="line">painter-&gt;<span class="built_in">drawText</span>(r, flags, text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numTipVisible) &#123;</span><br><span class="line">    <span class="type">const</span> qreal radius = heightNumTip / <span class="number">2</span>;</span><br><span class="line">    QRectF rectNumTip = <span class="built_in">QRect</span>(r.<span class="built_in">left</span>() + xNumTip + leftMargin, newOption.rect.<span class="built_in">top</span>() + (newOption.rect.<span class="built_in">height</span>() - heightNumTip) / <span class="number">2</span>,</span><br><span class="line">                                widthNumTip, heightNumTip);</span><br><span class="line"></span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.<span class="built_in">moveTo</span>(rectNumTip.<span class="built_in">bottomRight</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">    path.<span class="built_in">lineTo</span>(rectNumTip.<span class="built_in">topRight</span>() + <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">    path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rectNumTip.<span class="built_in">topRight</span>() - <span class="built_in">QPointF</span>(radius * <span class="number">2</span>, <span class="number">0</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius *<span class="number">2</span>)), <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">    path.<span class="built_in">lineTo</span>(rectNumTip.<span class="built_in">topLeft</span>() + <span class="built_in">QPointF</span>(radius, <span class="number">0</span>));</span><br><span class="line">    path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rectNumTip.<span class="built_in">topLeft</span>()), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line">    path.<span class="built_in">lineTo</span>(rectNumTip.<span class="built_in">bottomLeft</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius));</span><br><span class="line">    path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rectNumTip.<span class="built_in">bottomLeft</span>() - <span class="built_in">QPointF</span>(<span class="number">0</span>, radius * <span class="number">2</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">180</span>, <span class="number">90</span>);</span><br><span class="line">    path.<span class="built_in">lineTo</span>(rectNumTip.<span class="built_in">bottomLeft</span>() + <span class="built_in">QPointF</span>(radius, <span class="number">0</span>));</span><br><span class="line">    path.<span class="built_in">arcTo</span>(<span class="built_in">QRectF</span>(<span class="built_in">QPointF</span>(rectNumTip.<span class="built_in">bottomRight</span>() - <span class="built_in">QPointF</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="built_in">QSize</span>(radius * <span class="number">2</span>, radius * <span class="number">2</span>)), <span class="number">270</span>, <span class="number">90</span>);</span><br><span class="line">    painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    painter-&gt;<span class="built_in">fillPath</span>(path, <span class="built_in">QColor</span>(Qt::red));</span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">save</span>();</span><br><span class="line">    QPen pen = painter-&gt;<span class="built_in">pen</span>();</span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">2</span>);</span><br><span class="line">    pen.<span class="built_in">setColor</span>(Qt::white);</span><br><span class="line">    painter-&gt;<span class="built_in">setPen</span>(pen);</span><br><span class="line">    painter-&gt;<span class="built_in">drawText</span>(rectNumTip, Qt::AlignCenter, QString::<span class="built_in">number</span>(num));</span><br><span class="line">    painter-&gt;<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/images/QtExamples-NumTipNearText.png" alt="QtExamples-NumTipNearText"></p>]]></content>
      
      
      <categories>
          
          <category> QtExamples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtExamples </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QMenu</title>
      <link href="/2022/04/19/Qt/QMenu/"/>
      <url>/2022/04/19/Qt/QMenu/</url>
      
        <content type="html"><![CDATA[<h2 id="函数介绍">函数介绍</h2><p>1.<strong><code>void setContextMenuPolicy(Qt::ContextMenuPolicy policy)</code></strong></p><p>This enum type defines the various policies a widget can have with respect to showing a context menu.</p><table><thead><tr><th style="text-align:left">Constant</th><th style="text-align:center">Value</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">Qt::NoContextMenu</td><td style="text-align:center">0</td><td style="text-align:left">the widget does not feature a context menu, context menu handling is deferred to the widget’s parent.</td></tr><tr><td style="text-align:left">Qt::PreventContextMenu</td><td style="text-align:center">4</td><td style="text-align:left">the widget does not feature a context menu, and in contrast to NoContextMenu, the handling is not deferred to the widget’s parent. This means that all right mouse button events are guaranteed to be delivered to the widget itself through QWidget::mousePressEvent(), and QWidget::mouseReleaseEvent().</td></tr><tr><td style="text-align:left">Qt::DefaultContextMenu</td><td style="text-align:center">1</td><td style="text-align:left">the widget’s QWidget::contextMenuEvent() handler is called.</td></tr><tr><td style="text-align:left">Qt::ActionsContextMenu</td><td style="text-align:center">2</td><td style="text-align:left">the widget displays its QWidget::actions() as context menu.</td></tr><tr><td style="text-align:left">Qt::CustomContextMenu</td><td style="text-align:center">3</td><td style="text-align:left">the widget emits the QWidget::customContextMenuRequested() signal.</td></tr></tbody></table><h2 id="示例-2">示例</h2><h3 id="示例1：创建上下文菜单（createContextMenu）">示例1：创建上下文菜单（createContextMenu）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createContextMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">contextMenuEvent</span><span class="params">(QContextMenuEvent *e)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QMenu *m_menu = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::createContextMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_menu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(ui-&gt;tableWidget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> actionAdd = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(), <span class="built_in">tr</span>(<span class="string">&quot;增加行&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(actionAdd, &amp;QAction::triggered, <span class="keyword">this</span>, [&amp;](<span class="type">bool</span>)&#123; ui-&gt;tableWidget-&gt;<span class="built_in">insertRow</span>(ui-&gt;tableWidget-&gt;<span class="built_in">rowCount</span>()); &#125;);</span><br><span class="line">    m_menu-&gt;<span class="built_in">addAction</span>(actionAdd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> actionIns = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(), <span class="built_in">tr</span>(<span class="string">&quot;插入行&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(actionIns, &amp;QAction::triggered, <span class="keyword">this</span>, [&amp;](<span class="type">bool</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> index = ui-&gt;tableWidget-&gt;<span class="built_in">rowCount</span>() == <span class="number">0</span> ? <span class="number">0</span> : ui-&gt;tableWidget-&gt;<span class="built_in">currentRow</span>() + <span class="number">1</span>;</span><br><span class="line">        ui-&gt;tableWidget-&gt;<span class="built_in">insertRow</span>(index);</span><br><span class="line">    &#125;);</span><br><span class="line">    m_menu-&gt;<span class="built_in">addAction</span>(actionIns);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> actionDel = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(), <span class="built_in">tr</span>(<span class="string">&quot;删除行&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(actionDel, &amp;QAction::triggered, <span class="keyword">this</span>, [&amp;](<span class="type">bool</span>)&#123; ui-&gt;tableWidget-&gt;<span class="built_in">removeRow</span>(ui-&gt;tableWidget-&gt;<span class="built_in">currentRow</span>()); &#125;);</span><br><span class="line">    m_menu-&gt;<span class="built_in">addAction</span>(actionDel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置小部件的上下文菜单</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::ActionsContextMenu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::contextMenuEvent</span><span class="params">(QContextMenuEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_menu-&gt;<span class="built_in">exec</span>(e-&gt;<span class="built_in">globalPos</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改 Qt Creator 界面样式</title>
      <link href="/2022/04/18/Qt/%E4%BF%AE%E6%94%B9QtCreator%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F/"/>
      <url>/2022/04/18/Qt/%E4%BF%AE%E6%94%B9QtCreator%E7%95%8C%E9%9D%A2%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：是修改 Qt Creator 界面字体样式，并不是编辑器里代码的字体样式。</p></blockquote><h2 id="先上效果图">先上效果图</h2><ul><li><p>黑色主题<br><img src="/assets/images/QtCreator-def-font.png" alt="QtCreator-def-font"><br><img src="/assets/images/QtCreator-modify-font-jet-mono.png" alt="QtCreator-modify-font-jet-mono"><br><img src="/assets/images/QtCreator-modify-font-help-doc-not-good.png" alt="QtCreator-modify-font-help-doc-not-good"></p></li><li><p>白色主题<br><img src="/assets/images/QtCreator-def-font-white.png" alt="QtCreator-def-font-white"><br><img src="/assets/images/QtCreator-modify-font-jet-mono-white.png" alt="QtCreator-modify-font-jet-mono-white"></p></li></ul><blockquote><p>由于是全局的 qss，效果会有所差别，但白色主题还看的过去。</p></blockquote><h2 id="具体操作">具体操作</h2><p>0.安装 <a href="https://github.com/JetBrains/JetBrainsMono">JetBrains Mono</a> 字体（下载解压后打开 <code>font/ttf</code> 文件夹，全选右键安装）</p><p>1.新建一个 <code>.css</code> 文件并填写如下内容，然后保存（例如放在：<code>C:\Qt\qtcreator-custom-style\qtcreator-custom-style.css</code>）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QWidget &#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">10pt</span> <span class="string">&quot;JetBrains Mono&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.找到 Qt Creator 的快捷方式，鼠标右键，选择’快捷方式’页，在’目标’编辑框加上 ’ --stylesheet=刚才新建的 css 文件路径’。<br><img src="/assets/images/QtCreator-custom-font.png" alt="QtCreator-custom-font"></p><p>例如：<code>C:\Qt\qtcreator-5.0.2\bin\qtcreator.exe --stylesheet=C:\Qt\qtcreator-custom-style\qtcreator-custom-style.css</code></p>]]></content>
      
      
      <categories>
          
          <category> QtCreator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QtCreator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QFileInfo</title>
      <link href="/2022/04/15/Qt/QFileInfo/"/>
      <url>/2022/04/15/Qt/QFileInfo/</url>
      
        <content type="html"><![CDATA[<h2 id="QFileInfo-成员函数介绍">QFileInfo 成员函数介绍</h2><p>1.<strong><code>QString QFileInfo::fileName() const</code></strong><br>Returns the name of the file, excluding the path.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">fi</span><span class="params">(<span class="string">&quot;/tmp/archive.tar.gz&quot;</span>)</span></span>;</span><br><span class="line">QString name = fi.<span class="built_in">fileName</span>();         <span class="comment">// name = &quot;archive.tar.gz&quot;</span></span><br></pre></td></tr></table></figure><p>Note that, if this QFileInfo object is given a path ending in a slash, the name of the file is considered empty.</p><p>2.<strong><code>QString QFileInfo::completeBaseName() const</code></strong><br>Returns the complete base name of the file without the path.<br>The complete base name consists of all characters in the file up to (but not including) the last ‘.’ character.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">fi</span><span class="params">(<span class="string">&quot;/tmp/archive.tar.gz&quot;</span>)</span></span>;</span><br><span class="line">QString base = fi.<span class="built_in">completeBaseName</span>();  <span class="comment">// base = &quot;archive.tar&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写博客要注意的一些问题</title>
      <link href="/2022/04/15/Hexo-Blog/%E5%86%99%E5%8D%9A%E5%AE%A2%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/15/Hexo-Blog/%E5%86%99%E5%8D%9A%E5%AE%A2%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="标题">标题</h2><p>hexo 新建文章后自动生成的</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxxx</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>其实就是一级标题</p><p><img src="/assets/images/Blog-header.png" alt="Blog-header"></p><h2 id="source-posts-文件夹">source/_posts 文件夹</h2><p>hexo 新建的文章自动生成在 source/_posts 文件夹下</p><p>可以通过手工把同一类文章放到同一个文件夹下（比如：Qt 相关的文章都移动到 Qt 文件夹内），而且通过 hexo 生成、部署后的网页并没有影响</p><h2 id="资源文件">资源文件</h2><p>在文章中引用的图片资源</p><p>可以统一放到资源文件夹 source/images，避免资源重复浪费空间、流量</p><p>在文章中通过 <code>![xxx](/assets/images/xxx.png)</code> 引用即可</p><h2 id="关于文章的一些约定">关于文章的一些约定</h2><ul><li>1.文章分类</li><li>2.文章标签</li><li>3.文章命名</li><li>4.文章配图命名</li><li>5.文章名称和标题不用一样</li></ul><h2 id="文章加载问题">文章加载问题</h2><ul><li><p>1.文章列表加载问题</p><p>网页加载慢，可以禁用文章列表图片</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-cover: /assets/images/logo/QtCreator.png</span><br><span class="line">cover: false</span><br></pre></td></tr></table></figure></li><li><p>2.文章内容加载问题</p><p>文章内容加载慢，可以减少文章配图，或者不用配图（有时候配图可以更加直观易懂）</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QRegExp</title>
      <link href="/2022/04/15/Qt/QRegExp/"/>
      <url>/2022/04/15/Qt/QRegExp/</url>
      
        <content type="html"><![CDATA[<h2 id="QRegExp-成员函数介绍">QRegExp 成员函数介绍</h2><p>1.<strong><code>QString QRegExp::cap(int nth = 0) const</code></strong></p><p>Returns the text captured by the nth subexpression. The entire match has index 0 and the parenthesized subexpressions have indexes starting from 1 (excluding non-capturing parentheses).</p><blockquote><p>返回第 n 个子表达式捕获的文本。整个匹配的索引为 0，带括号的子表达式的索引从 1 开始（不包括非捕获括号）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRegExp <span class="title">rxlen</span><span class="params">(<span class="string">&quot;(\\d+)(?:\\s*)(cm|inch)&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> pos = rxlen.<span class="built_in">indexIn</span>(<span class="string">&quot;Length: 189cm&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    QString value = rxlen.<span class="built_in">cap</span>(<span class="number">1</span>); <span class="comment">// &quot;189&quot;</span></span><br><span class="line">    QString unit = rxlen.<span class="built_in">cap</span>(<span class="number">2</span>);  <span class="comment">// &quot;cm&quot;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The order of elements matched by cap() is as follows. The first element, cap(0), is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus cap(1) is the text of the first capturing parentheses, cap(2) is the text of the second, and so on.</p><blockquote><p>cap() 匹配的元素顺序如下。第一个元素 cap(0) 是整个匹配字符串。每个后续元素对应于下一个捕获左括号。因此 cap(1) 是第一个捕获括号的文本，cap(2) 是第二个捕获括号的文本，依此类推。</p></blockquote><p>2.<strong><code>bool QRegExp::exactMatch(const QString &amp;str) const</code></strong></p><p>Returns true if str is matched exactly by this regular expression; otherwise returns false. You can determine how much of the string was matched by calling matchedLength().<br>For a given regexp string R, exactMatch(“R”) is the equivalent of indexIn(“^R$”) since exactMatch() effectively encloses the regexp in the start of string and end of string anchors, except that it sets matchedLength() differently.<br>For example, if the regular expression is blue, then exactMatch() returns true only for input blue. For inputs bluebell, blutak and lightblue, exactMatch() returns false and matchedLength() will return 4, 3 and 0 respectively.</p><blockquote><p>如果 str 与此正则表达式完全匹配，则返回 true； 否则返回假。 您可以通过调用matchedLength() 来确定字符串的匹配程度。<br>对于给定的正则表达式字符串 R，exactMatch(“R”) 等效于 indexIn(“^R$”)，因为exactMatch() 有效地将正则表达式包含在字符串的开头和字符串锚点的结尾，除了它设置matchedLength( ) 不同。<br>例如，如果正则表达式为蓝色，则exactMatch() 仅对输入蓝色返回true。 对于输入 bluebell、blutak 和 lightblue，exactMatch() 返回 false，matchedLength() 将分别返回 4、3 和 0。</p></blockquote><p>3.<strong><code>int QRegExp::indexIn(const QString &amp;str, int offset = 0, QRegExp::CaretMode caretMode = CaretAtZero) const</code></strong></p><p>Attempts to find a match in str from position offset (0 by default). If offset is -1, the search starts at the last character; if -2, at the next to last character; etc.<br>Returns the position of the first match, or -1 if there was no match.<br>The caretMode parameter can be used to instruct whether ^ should match at index 0 or at offset.<br>You might prefer to use QString::indexOf(), QString::contains(), or even QStringList::filter(). To replace matches use QString::replace().</p><blockquote><p>尝试从位置偏移量（默认为 0）在 str 中找到匹配项。 如果 offset 为 -1，则从最后一个字符开始搜索； 如果 -2，则在倒数第二个字符处； 等等<br>返回第一个匹配的位置，如果没有匹配则返回 -1。<br>caretMode 参数可用于指示 ^ 是否应在索引 0 处匹配或在偏移处匹配。<br>你可能更喜欢使用 QString::indexOf()、QString::contains()，甚至是 QStringList::filter()。 要替换匹配项，请使用 QString::replace()。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QString str = <span class="string">&quot;offsets: 1.23 .50 71.00 6.00&quot;</span>;</span><br><span class="line"><span class="function">QRegExp <span class="title">rx</span><span class="params">(<span class="string">&quot;\\d*\\.\\d+&quot;</span>)</span></span>;    <span class="comment">// primitive floating point matching</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((pos = rx.<span class="built_in">indexIn</span>(str, pos)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    ++count;</span><br><span class="line">    pos += rx.<span class="built_in">matchedLength</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pos will be 9, 14, 18 and finally 24; count will end up as 4</span></span><br></pre></td></tr></table></figure><p>Although const, this function sets matchedLength(), capturedTexts() and pos().<br>If the QRegExp is a wildcard expression (see setPatternSyntax()) and want to test a string against the whole wildcard expression, use exactMatch() instead of this function.</p><blockquote><p>虽然返回值是 const，但该函数设置了matchedLength()、cappedTexts() 和pos()。<br>如果 QRegExp 是通配符表达式（请参阅 setPatternSyntax()）并且想要针对整个通配符表达式测试字符串，请使用 exactMatch() 而不是此函数。</p></blockquote><h2 id="示例-3">示例</h2><h3 id="示例1：匹配、获取小括号内容">示例1：匹配、获取小括号内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">QString text = <span class="string">&quot;qw2(1,2,3,4)223(342)32(1,,3,4)31we&quot;</span></span><br><span class="line"></span><br><span class="line">QRegExp <span class="built_in">re</span>(<span class="string">&quot;\\(.*\\)&quot;</span>); <span class="comment">// 括号及括号内部的任何字符。</span></span><br><span class="line"><span class="keyword">if</span> (re.<span class="built_in">indexIn</span>(text, <span class="number">0</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = re.<span class="built_in">cap</span>(<span class="number">0</span>); <span class="comment">// ret = &quot;(1,2,3,4)223(342)32(1,,3,4)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QRegExp <span class="title">re</span><span class="params">(<span class="string">&quot;\\([^)]*\\)&quot;</span>)</span></span>; <span class="comment">// 从一个开括号到最近的闭括号。</span></span><br><span class="line"><span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">QStringList list;</span><br><span class="line"><span class="keyword">while</span> ((pos = exp.<span class="built_in">indexIn</span>(text, pos)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    list &lt;&lt; exp.<span class="built_in">cap</span>(<span class="number">1</span>);</span><br><span class="line">    pos += exp.<span class="built_in">matchedLength</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; list; <span class="comment">// (1,2,3,4), (342), (1,,3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="function">QRegExp <span class="title">rx</span><span class="params">(<span class="string">&quot;(\\d+)&quot;</span>)</span></span>;</span><br><span class="line">QString str = <span class="string">&quot;Offsets: 12 14 99 231 7&quot;</span>;</span><br><span class="line">QStringList list1;</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((pos = rx.<span class="built_in">indexIn</span>(str, pos)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    list1 &lt;&lt; rx.<span class="built_in">cap</span>(<span class="number">1</span>);</span><br><span class="line">    pos += rx.<span class="built_in">matchedLength</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;list1:&quot;</span> &lt;&lt; list1;</span><br><span class="line"><span class="comment">// list1: [&quot;12&quot;, &quot;14&quot;, &quot;99&quot;, &quot;231&quot;, &quot;7&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="示例2：匹配内容">示例2：匹配内容</h3><blockquote><p>全内容匹配，使用 exactMatch()</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QString text = <span class="string">&quot;(1,2,3,4)&quot;</span>;</span><br><span class="line">QString text1 = <span class="string">&quot;11(1,2,3,4)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QRegExp <span class="title">exp</span><span class="params">(<span class="string">&quot;\\(.*\\)&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; exp.<span class="built_in">exactMatch</span>(text); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt; exp.<span class="built_in">exactMatch</span>(text1); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 给图片添加水印</title>
      <link href="/2022/04/08/Python/Python-Add-Watermarking/"/>
      <url>/2022/04/08/Python/Python-Add-Watermarking/</url>
      
        <content type="html"><![CDATA[<h2 id="示例">示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_text</span>(<span class="params">img_path, text=<span class="string">&#x27;svinda.github.io&#x27;</span>, show_result_image=<span class="literal">False</span></span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    font = ImageFont.truetype(<span class="string">&#x27;C:/windows/fonts/Arial.ttf&#x27;</span>, size=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># color = (255, 222, 111)</span></span><br><span class="line">    width, height = img.size</span><br><span class="line">    draw.text((width - <span class="number">150</span>, height - <span class="number">55</span>), text, (<span class="number">14</span>, <span class="number">222</span>, <span class="number">111</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加透明度</span></span><br><span class="line">    draw.text((width - <span class="number">150</span>, height - <span class="number">35</span>), text, (<span class="number">14</span>, <span class="number">222</span>, <span class="number">111</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加字体</span></span><br><span class="line">    draw.text((width - <span class="number">150</span>, height - <span class="number">75</span>), text, (<span class="number">14</span>, <span class="number">222</span>, <span class="number">111</span>), font=font)</span><br><span class="line">    ImageDraw.Draw(img)</span><br><span class="line"></span><br><span class="line">    (path, suffix) = os.path.splitext(img_path)</span><br><span class="line">    <span class="built_in">print</span>(path, suffix)</span><br><span class="line">    img.save(path + <span class="string">&#x27;_watermark.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> show_result_image:</span><br><span class="line">        <span class="comment">## （阻塞）打开添加水印后的图片</span></span><br><span class="line">        img.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多张图片添加同一水印</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_text_all</span>(<span class="params">img_paths=[], text=<span class="string">&#x27;svinda.github.io&#x27;</span>, show_result_image=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">for</span> img_path <span class="keyword">in</span> img_paths:</span><br><span class="line">        add_text(img_path, text, show_result_image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    image_path = <span class="string">r&quot;images\hexo-文章插入图片.png&quot;</span></span><br><span class="line">    add_text(image_path, <span class="string">&#x27;svinda.github.io&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add_text_all([<span class="string">r&quot;images\hexo-文章插入图片.png&quot;</span>, <span class="string">r&quot;images\hexo-文章插入图片 - 副本.png&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果图<br><img src="/assets/images/hexo-%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87_watermark.png" alt="插入图片_watermark"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt Creator 源码分析：入口函数分析</title>
      <link href="/2022/04/06/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-main()%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/"/>
      <url>/2022/04/06/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-main()%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0-程序-main-函数执行流程图">0.程序 <code>main()</code> 函数执行流程图</h2><p><img src="/assets/images/QtCreator-%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="QtCreator-程序入口流程图.png"></p><h2 id="1-Restarter-restarter-argc-argv">1.<code>Restarter restarter(argc, argv)</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Restarter <span class="title">restarter</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> restarter.<span class="built_in">restartOrExit</span>(app.<span class="built_in">exec</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序重启器，用于某些配置修改后，需要重启程序才能够使配置生效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restarter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Restarter</span>(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Q_UNUSED</span>(argc)</span><br><span class="line">        m_executable = QString::<span class="built_in">fromLocal8Bit</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        m_workingPath = QDir::<span class="built_in">currentPath</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setArguments</span><span class="params">(<span class="type">const</span> QStringList &amp;args)</span> </span>&#123; m_args = args; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QString <span class="title">executable</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_executable; &#125;</span><br><span class="line">    <span class="function">QStringList <span class="title">arguments</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_args; &#125;</span><br><span class="line">    <span class="function">QString <span class="title">workingPath</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_workingPath; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">restartOrExit</span><span class="params">(<span class="type">int</span> exitCode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 根据 &quot;restart&quot; 属性判断是需要重启程序</span></span><br><span class="line">        <span class="keyword">return</span> qApp-&gt;<span class="built_in">property</span>(<span class="string">&quot;restart&quot;</span>).<span class="built_in">toBool</span>() ? <span class="built_in">restart</span>(exitCode) : exitCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">restart</span><span class="params">(<span class="type">int</span> exitCode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 启动进程</span></span><br><span class="line">        QProcess::<span class="built_in">startDetached</span>(m_executable, m_args, m_workingPath);</span><br><span class="line">        <span class="keyword">return</span> exitCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_executable;  <span class="comment">// 可执行程序名称</span></span><br><span class="line">    QStringList m_args;    <span class="comment">// 可执行程序的命令参数</span></span><br><span class="line">    QString m_workingPath; <span class="comment">// 可执行程序所在的工作目录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-SharedTools-QtSingleApplication-app">2.<code>SharedTools::QtSingleApplication app()</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">SharedTools::QtSingleApplication <span class="title">app</span><span class="params">((QLatin1String(Core::Constants::IDE_DISPLAY_NAME)),</span></span></span><br><span class="line"><span class="params"><span class="function">                                         numberofArguments,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         options.appArguments.data())</span></span>;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> QT_VERSION &lt; QT_VERSION_CHECK(6, 0, 0)</span></span><br><span class="line">    app.<span class="built_in">setAttribute</span>(Qt::AA_UseHighDpiPixmaps);</span><br><span class="line">    app.<span class="built_in">setAttribute</span>(Qt::AA_DisableWindowContextHelpButton);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">    QTranslator translator;</span><br><span class="line">    QTranslator qtTranslator;</span><br><span class="line">......</span><br><span class="line">    app.<span class="built_in">installTranslator</span>(&amp;translator);</span><br><span class="line">    app.<span class="built_in">installTranslator</span>(&amp;qtTranslator);</span><br><span class="line">    app.<span class="built_in">setProperty</span>(<span class="string">&quot;qtc_locale&quot;</span>, locale);</span><br><span class="line">......</span><br><span class="line">    app.<span class="built_in">setDesktopFileName</span>(<span class="string">&quot;org.qt-project.qtcreator.desktop&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isBlock = foundAppOptions.<span class="built_in">contains</span>(<span class="built_in">QLatin1String</span>(BLOCK_OPTION));</span><br><span class="line">    <span class="keyword">if</span> (app.<span class="built_in">isRunning</span>() &amp;&amp; (pid != <span class="number">-1</span> || isBlock</span><br><span class="line">                            || foundAppOptions.<span class="built_in">contains</span>(<span class="built_in">QLatin1String</span>(CLIENT_OPTION)))) &#123;</span><br><span class="line">        app.<span class="built_in">setBlock</span>(isBlock);</span><br><span class="line">        <span class="keyword">if</span> (app.<span class="built_in">sendMessage</span>(PluginManager::<span class="built_in">serializedArguments</span>(), <span class="number">5000</span> <span class="comment">/*timeout*/</span>, pid))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Message could not be send, maybe it was in the process of quitting</span></span><br><span class="line">        <span class="keyword">if</span> (app.<span class="built_in">isRunning</span>(pid)) &#123;</span><br><span class="line">            <span class="comment">// Nah app is still running, ask the user</span></span><br><span class="line">            <span class="type">int</span> button = <span class="built_in">askMsgSendFailed</span>();</span><br><span class="line">            <span class="keyword">while</span> (button == QMessageBox::Retry) &#123;</span><br><span class="line">                <span class="keyword">if</span> (app.<span class="built_in">sendMessage</span>(PluginManager::<span class="built_in">serializedArguments</span>(), <span class="number">5000</span> <span class="comment">/*timeout*/</span>, pid))</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!app.<span class="built_in">isRunning</span>(pid)) <span class="comment">// App quit while we were trying so start a new creator</span></span><br><span class="line">                    button = QMessageBox::Yes;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    button = <span class="built_in">askMsgSendFailed</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (button == QMessageBox::No)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up remote arguments.</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;app, &amp;SharedTools::QtSingleApplication::messageReceived,</span><br><span class="line">                     &amp;pluginManager, &amp;PluginManager::remoteArguments);</span><br><span class="line"></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;app, <span class="built_in">SIGNAL</span>(<span class="built_in">fileOpenRequest</span>(QString)), coreplugin-&gt;<span class="built_in">plugin</span>(),</span><br><span class="line">                     <span class="built_in">SLOT</span>(<span class="built_in">fileOpenRequest</span>(QString)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown plugin manager on the exit</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;app, &amp;QCoreApplication::aboutToQuit, &amp;pluginManager, &amp;PluginManager::shutdown);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> restarter.<span class="built_in">restartOrExit</span>(app.<span class="built_in">exec</span>());</span><br></pre></td></tr></table></figure><p>QtSingleApplication 提供了每个用户只能启动一次的应用程序的功能。<br>Qt 提供了解决方案组件项目 qtproject/qt-solutions <a href="https://github.com/qtproject/qt-solutions">https://github.com/qtproject/qt-solutions</a><br>Qt Creator 里的 QtSingleApplication 和 qt-solutions 有些不一样</p><p>qtproject/qt-solutions 提供的解决方案项目在另外的篇章展开分析：QtSingleApplication（TODO）</p><h2 id="3-程序工作环境配置">3.程序工作环境配置</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">QCoreApplication::<span class="built_in">setApplicationName</span>(Core::Constants::IDE_CASED_ID);</span><br><span class="line">QCoreApplication::<span class="built_in">setApplicationVersion</span>(<span class="built_in">QLatin1String</span>(Core::Constants::IDE_VERSION_LONG));</span><br><span class="line">QCoreApplication::<span class="built_in">setOrganizationName</span>(<span class="built_in">QLatin1String</span>(Core::Constants::IDE_SETTINGSVARIANT_STR));</span><br><span class="line">QGuiApplication::<span class="built_in">setApplicationDisplayName</span>(Core::Constants::IDE_DISPLAY_NAME);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cleanup = <span class="built_in">qScopeGuard</span>([] &#123; Utils::Singleton::<span class="built_in">deleteAll</span>(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> QStringList pluginArguments = app.<span class="built_in">arguments</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Initialize global settings and resetup install settings with QApplication::applicationDirPath */</span></span><br><span class="line"><span class="built_in">setupInstallSettings</span>(options.installSettingsPath);</span><br><span class="line">Utils::QtcSettings *settings = <span class="built_in">createUserSettings</span>();</span><br><span class="line"><span class="comment">// static Utils::QtcSettings *createUserSettings()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return new Utils::QtcSettings(QSettings::IniFormat,</span></span><br><span class="line"><span class="comment">//                                   QSettings::UserScope,</span></span><br><span class="line"><span class="comment">//                                   QLatin1String(Core::Constants::IDE_SETTINGSVARIANT_STR),</span></span><br><span class="line"><span class="comment">//                                   QLatin1String(Core::Constants::IDE_CASED_ID));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Utils::QtcSettings *globalSettings</span><br><span class="line">    = <span class="keyword">new</span> Utils::<span class="built_in">QtcSettings</span>(QSettings::IniFormat,</span><br><span class="line">                             QSettings::SystemScope,</span><br><span class="line">                             <span class="built_in">QLatin1String</span>(Core::Constants::IDE_SETTINGSVARIANT_STR),</span><br><span class="line">                             <span class="built_in">QLatin1String</span>(Core::Constants::IDE_CASED_ID));</span><br><span class="line">Utils::TerminalCommand::<span class="built_in">setSettings</span>(settings);</span><br><span class="line"><span class="built_in">loadFonts</span>();</span><br><span class="line"><span class="comment">// void loadFonts()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     const QDir dir(resourcePath() + &quot;/fonts/&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     const QFileInfoList fonts = dir.entryInfoList(QStringList(&quot;*.ttf&quot;), QDir::Files);</span></span><br><span class="line"><span class="comment">//     for (const QFileInfo &amp;fileInfo : fonts)</span></span><br><span class="line"><span class="comment">//         QFontDatabase::addApplicationFont(fileInfo.absoluteFilePath());</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>主要理解这两个代表什么就行了<br><code>QSettings::UserScope</code><br><code>QSettings::SystemScope</code></p><p>TODO：QSettings 需要另外的篇章介绍。</p><h2 id="4-PluginManager-pluginManager">4.<code>PluginManager pluginManager</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PluginManager pluginManager;</span><br><span class="line">PluginManager::<span class="built_in">setPluginIID</span>(<span class="built_in">QLatin1String</span>(<span class="string">&quot;org.qt-project.Qt.QtCreatorPlugin&quot;</span>));</span><br><span class="line">PluginManager::<span class="built_in">setGlobalSettings</span>(globalSettings);</span><br><span class="line">PluginManager::<span class="built_in">setSettings</span>(settings);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 读取所有路径下的插件属性信息</span></span><br><span class="line">PluginManager::<span class="built_in">setPluginPaths</span>(pluginPaths);</span><br><span class="line">...</span><br><span class="line">PluginManager::<span class="built_in">checkForProblematicPlugins</span>();</span><br><span class="line"><span class="comment">// 加载插件</span></span><br><span class="line">PluginManager::<span class="built_in">loadPlugins</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt Creator 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtCreator </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt Creator 源码分析：程序入口</title>
      <link href="/2022/04/06/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3/"/>
      <url>/2022/04/06/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="分析程序入口">分析程序入口</h2><p>在键盘上按下 F10 键，Qt Creator 便会启动调试并且自动定位到 <code>main()</code> 函数处，在不知道程序入口的情况下，这种方法是最好用的。<br>如果是知道程序入口，那么可以在入口处打上断点，然后启动调试，也会定位到断点处。</p>]]></content>
      
      
      <categories>
          
          <category> Qt Creator 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtCreator </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt Creator 源码分析：目录分析</title>
      <link href="/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90/"/>
      <url>/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="目录树">目录树</h2><p>qt-creator-opensource-src-7.0.0 目录树</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qt-creator-opensource-src-7.0.0:</span><br><span class="line">├─bin</span><br><span class="line">├─cmake</span><br><span class="line">├─coin</span><br><span class="line">├─dist</span><br><span class="line">├─doc</span><br><span class="line">├─qbs</span><br><span class="line">├─scripts</span><br><span class="line">├─share</span><br><span class="line">├─src</span><br><span class="line">└─test</span><br></pre></td></tr></table></figure><!-- bin: 生成Linux平台shell脚本。dist: 安装文件配置信息和版本更新记录。doc: 生成doxygen文档的配置文件。lib:Qt组件相关的QML文件qbs:QBS 配置文件。QBS，即 Qt Build Suite，是一种跨平台的编译工具，目的是将高层的项目描述（使用类似QML的语言）转换成底层的编译描述（供 make 等工具使用的信息）。它可以简化多平台的编译过程。QBS与qmake类似，区别在于前者适用于任意项目，而后者一般仅供Qt项目使用。在阅读代码时将关注 qmake，不会深入研究QBS的使用。scripts: QtCreator使用的perl以及python等脚本。share: 源代码中所需要的一些非代码共享文件，例如代码模板等。src: QtCreator源代码文件。tests: QtCreator测试代码。HACKING: QtCreator编码规范。LICENSE.LGPL: LGPL协议。qtcreator.pri: QtCreator项目需要使用的通用配置，一般会被include到大部分 pro文件。qtcreator.pro: QtCreator的qmake项目文件。qtcreator.qbs:  Qt Creator 的 QBS 项目文件。README: 有关如何编译QtCreator等相关事宜的一些说明。.gitignore: git忽略文件配置。.gitmodules:git 子模块配置 --><h2 id="目录说明">目录说明</h2><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>生成Linux平台shell脚本。</td></tr><tr><td>cmake</td><td>cmake扩展文件</td></tr><tr><td>coin</td><td>用于Qt Creator 持续集成部署的一些yaml脚本</td></tr><tr><td>dist</td><td>安装文件配置信息和版本更新记录。</td></tr><tr><td>doc</td><td>生成doxygen文档的配置文件。</td></tr><tr><td>qbs</td><td>.qbs配置文件。qbs(Qt Build Suite)是一种跨平台的编译工具。</td></tr><tr><td>scripts</td><td>QtCreator使用的perl以及python等脚本。</td></tr><tr><td>share</td><td>源代码中所需要的一些非代码共享文件，例如代码模板等。</td></tr><tr><td>src</td><td>QtCreator源代码文件。</td></tr><tr><td>test</td><td>QtCreator测试代码。</td></tr></tbody></table><h2 id="代码文件分析">代码文件分析</h2><p>使用 <a href="https://github.com/AlDanial/cloc">cloc</a> 对 qt-creator-opensource-src-7.0.0\src 进行统计分析</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cloc-1.92.exe D:\QtSource\qt-creator-opensource-src-7.0.0\src</span><br><span class="line">   13515 text files.</span><br><span class="line">   12511 unique files.</span><br><span class="line">    2485 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.92  T=19.60 s (638.2 files/s, 133709.7 lines/s)</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">Language                             files          blank        comment           code</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">C++                                   4125         183463         165252        1004980</span><br><span class="line">C/C++ Header                          4464          84265         143565         283244</span><br><span class="line">C                                      108          16768          77301         182758</span><br><span class="line">JavaScript                            1337          22995          67899         116613</span><br><span class="line">XML                                     73            976           1177          75675</span><br><span class="line">QML                                   1391           5956           8626          50085</span><br><span class="line">Qt                                     203             24              0          37726</span><br><span class="line">SVG                                     15             10             14          19945</span><br><span class="line">ANTLR Grammar                            4           1670            388          10959</span><br><span class="line">CMake                                  214            730            248           9788</span><br><span class="line">Python                                  35           1403            995           7506</span><br><span class="line">YAML                                    20             71            486           6538</span><br><span class="line">diff                                    13            195           2969           4419</span><br><span class="line">Objective-C++                           26            347            536           1904</span><br><span class="line">yacc                                     5            297             54           1847</span><br><span class="line">Markdown                                57            529              0           1828</span><br><span class="line">Assembly                                59            101            661           1683</span><br><span class="line">Qt Project                             138            408             23           1652</span><br><span class="line">Bourne Shell                            33            279           1076           1180</span><br><span class="line">JSON                                    40             35              0           1113</span><br><span class="line">CSS                                      9            185             28            909</span><br><span class="line">Java                                    31            135            217            693</span><br><span class="line">Perl                                     6            110            134            647</span><br><span class="line">Dockerfile                               8            103            136            562</span><br><span class="line">XSD                                      1             24            307            370</span><br><span class="line">Objective-C                             12             96            289            357</span><br><span class="line">ProGuard                                 5             64             30            242</span><br><span class="line">Qt Linguist                              5              0              0            193</span><br><span class="line">GLSL                                    12             52            293            175</span><br><span class="line">Bourne Again Shell                       1             37              1            155</span><br><span class="line">lex                                      8             48             76            148</span><br><span class="line">TypeScript                               8             20              1            125</span><br><span class="line">Protocol Buffers                         9             30             28             93</span><br><span class="line">WiX <span class="built_in">source</span>                               4              9              0             77</span><br><span class="line">Prolog                                   4             13             98             76</span><br><span class="line">Windows Resource File                    5             10              1             62</span><br><span class="line">DOS Batch                                6             24             49             54</span><br><span class="line">C<span class="comment">#                                       4              1              0             41</span></span><br><span class="line">Windows Module Definition                2              0              0             32</span><br><span class="line">sed                                      1              2              1             22</span><br><span class="line">PowerShell                               1              3              0             20</span><br><span class="line">HTML                                     1              0              0             18</span><br><span class="line">Visual Basic .NET                        1              0              0              7</span><br><span class="line">Meson                                    1              1              0              6</span><br><span class="line">MATLAB                                   2              0              0              5</span><br><span class="line">IDL                                      1              1              0              2</span><br><span class="line">F<span class="comment">#                                       1              0              0              1</span></span><br><span class="line">INI                                      1              0              0              1</span><br><span class="line">WiX string localization                  1              0              0              1</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">SUM:                                 12511         321490         472959        1826537</span><br><span class="line">---------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="构建项目配置文件">构建项目配置文件</h2><p>就我所用到用于 Qt 工程构建的配置文件方式有三种：<code>xx.qbs</code> <code>xx.pro</code> <code>CMakeLists.txt</code></p><p>但是这里 Qt Creator 7.0.0 只提供了 qbs 和 CMakeLists.txt 这两种构建方式</p>]]></content>
      
      
      <categories>
          
          <category> Qt Creator 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtCreator </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt Creator 源码分析：环境配置</title>
      <link href="/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Qt-Creator-简介">Qt Creator 简介</h2><p><strong>Qt Creator 在 GitHub 上的仓库</strong>：<a href="https://github.com/qt-creator/qt-creator">https://github.com/qt-creator/qt-creator</a></p><p>目前需要关注的地方如下原文：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Qt Creator</span><br><span class="line"></span><br><span class="line">Qt Creator is a cross-platform, integrated development environment (IDE)</span><br><span class="line">for application developers to create applications for multiple desktop, embedded,</span><br><span class="line">and mobile device platforms.</span><br><span class="line"></span><br><span class="line">The Qt Creator Manual is available at:</span><br><span class="line"></span><br><span class="line">https://doc.qt.io/qtcreator/index.html</span><br><span class="line"></span><br><span class="line">For an overview of the Qt Creator IDE, see:</span><br><span class="line"></span><br><span class="line">https://doc.qt.io/qtcreator/creator-overview.html</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Compiling Qt Creator</span><br><span class="line"></span><br><span class="line">Prerequisites:</span><br><span class="line"></span><br><span class="line">    Qt 5.15.2 or later</span><br><span class="line">    Qt WebEngine module for QtWebEngine based help viewer</span><br><span class="line">    On Windows:</span><br><span class="line">        MinGW with GCC 7 or Visual Studio 2017 or later</span><br><span class="line">        Python 3.5 or later (optional, needed for the python enabled debug helper)</span><br><span class="line">        Debugging Tools for Windows (optional, for MSVC debugging support with CDB)</span><br><span class="line">    On Mac OS X: latest Xcode</span><br><span class="line">    On Linux: GCC 7 or later</span><br><span class="line">    LLVM/Clang 10 or later (optional, LLVM/Clang 13 is recommended. See instructions on how to get LLVM.</span><br><span class="line">    The ClangFormat, ClangPchManager and ClangRefactoring use the LLVM C++ API.</span><br><span class="line">    Since the LLVM C++ API provides no compatibility guarantee, </span><br><span class="line">    if later versions don&#x27;t compile we don&#x27;t support that version.)</span><br><span class="line">    CMake</span><br><span class="line">    Ninja (recommended)</span><br><span class="line"></span><br><span class="line">The used toolchain has to be compatible with the one Qt was compiled with.</span><br></pre></td></tr></table></figure><p>Qt Creator 是一个跨平台的集成开发环境（IDE），供应用程序开发人员为多个桌面、嵌入式和移动设备平台创建应用程序。</p><p>Qt Creator 手册可从以下网站获得：<br><a href="https://doc.qt.io/qtcreator/index.html">https://doc.qt.io/qtcreator/index.html</a></p><p>有关Qt Creator IDE的概述，请参阅：<br><a href="https://doc.qt.io/qtcreator/creator-overview.html">https://doc.qt.io/qtcreator/creator-overview.html</a></p><p>……</p><p>编译 Qt Creator</p><p>前提条件：</p><ul><li>Qt 5.15.2 或更高版本</li><li>基于 QtWebEngine 的帮助查看器的 Qt WebEngine 模块</li><li>在 Windows 上：<ul><li>MinGW 与 GCC 7 或 Visual Studio 2017 或更高版本</li><li>Python 3.5 或更高版本（可选，支持 Python 的调试助手需要）</li><li>Windows 调试工具（可选，用于 CDB 的 MSVC 调试支持）</li></ul></li><li>在 Mac OS X 上：最新的 Xcode</li><li>在 Linux上：GCC 7 或更高版本</li><li>LLVM/CLAN 10 或更高版本（可选的，LLVM/CLAN 13）。参见如何获得 LLVM 的说明。ClangFormat，CLANPCHCHEMANDION 和 CLAGReF 重构使用 LLVM C++ API。由于 LLVM C++ API 没有提供兼容性保证，如果以后的版本不编译，我们不支持该版本。</li><li>CMake</li><li>Ninja（推荐）</li></ul><p>使用的工具链必须与编译Qt时使用的工具链兼容。</p><h2 id="环境说明">环境说明</h2><ul><li>Windows 10</li><li>Qt 5.15.2 MSVC 2019 64 bit</li><li>Qt Creator 7.0.0</li><li>磁盘空间至少要有 15G 空间</li></ul><h2 id="Qt-5-15-2-安装">Qt 5.15.2 安装</h2><p>自 Qt 5.15 开始，Qt 公司不再提供开源脱机安装程序，相关文章：<a href="https://www.qt.io/blog/qt-offering-changes-2020">https://www.qt.io/blog/qt-offering-changes-2020</a></p><p>可以通过 Qt 提供的在线安装器<a href="https://download.qt.io/official_releases/online_installers/">qt-unified-windows-x86-online.exe</a>来安装，但是需要注册 Qt 账户。</p><p><img src="/assets/images/QtCreator-Qt%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E5%99%A8.png" alt="QtCreator-Qt在线安装器"></p><p>双击启动 qt-unified-windows-x86-online.exe 注册账户后(已有账户跳过)，登录，勾选一些必勾选项后，把 Qt 5.15.2 打上勾，确定后便开始下载安装了，这个过程消耗的时间比较长。</p><h2 id="获取并编译-Qt-Creator-7-0-0-源码">获取并编译 Qt Creator 7.0.0 源码</h2><p><a href="https://download.qt.io/official_releases/qtcreator/7.0/7.0.0/">Qt Creator 7.0.0</a> <code>https://download.qt.io/official_releases/qtcreator/7.0/7.0.0/</code><br><img src="/assets/images/QtCreator-%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81.png" alt="QtCreator-获取源码"></p><p>这里提供了源码的三种方式压缩包，随便下载一个即可。</p><ol><li>解压到一个你认为比较赏心悦目的目录下</li><li>启动安装好的 Qt Creator (安装 Qt 5.15.2)</li><li>打开解压后 qt-creator-opensource-src-7.0.0 目录里的 qtcreator.qbs 勾选配置 Qt 5.15.2 MSVC 2019 64 bit<br>或者打开 CMakeLists.txt 勾选配置 Qt 6.2.1 MinGW 64 bit</li><li>点击编译即可</li></ol><p><img src="/assets/images/QtCreator-qbs-build.png" alt="QtCreator-qbs-build"><br><img src="/assets/images/QtCreator-cmake-build.png" alt="QtCreator-cmake-build"></p><p>编译完成后，运行。</p><p><img src="/assets/images/QtCreator-%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90.png" alt="QtCreator-编译完成"></p>]]></content>
      
      
      <categories>
          
          <category> Qt Creator 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtCreator </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt Creator 源码分析：序</title>
      <link href="/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-0-%E5%BA%8F/"/>
      <url>/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-0-%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>有打算分析 Qt Creator 源码的想法已经很久了，偶尔也会写一点，但是断断续续……</p><p>在做项目期间也有使用 Qt Creator 源码里的插件系统。</p><p>本着学习和提升的目的，开始写 Qt Creator 源码分析文章。</p><h2 id="目录">目录</h2><!-- markdown 的语法在 Hexo 中不兼容[Qt Creator 源码分析-1-环境配置](../QtCreator源码分析-1-环境配置)[Qt Creator 源码分析-2-目录分析](../QtCreator源码分析-2-目录分析)[Qt Creator 源码分析-3-程序入口](../QtCreator源码分析-3-程序入口)[Qt Creator 源码分析-4-main() 函数分析](../QtCreator源码分析-4-main()函数分析)--><!-- <a href="#">Post not found: _posts-subpath/文章文件名（不要后缀） 文章标题（可选）</a> --><ul><li><a href="/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-0-%E5%BA%8F/" title="‘Qt Creator 源码分析-0-序‘">‘Qt Creator 源码分析-0-序‘</a></li><li><a href="/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="Qt Creator 源码分析-1-环境配置">Qt Creator 源码分析-1-环境配置</a></li><li><a href="/2022/04/05/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90/" title="Qt Creator 源码分析-2-目录分析">Qt Creator 源码分析-2-目录分析</a></li><li><a href="/2022/04/06/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3/" title="Qt Creator 源码分析-3-程序入口">Qt Creator 源码分析-3-程序入口</a></li><li><a href="/2022/04/06/OpenSourceProjects/QtCreator/QtCreator%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-main()%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/" title="Qt Creator 源码分析-4-main()函数分析">Qt Creator 源码分析-4-main()函数分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Qt Creator 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtCreator </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 调用 QAxWidget(dsoframer.ocx) 嵌入 office</title>
      <link href="/2022/03/24/Qt/Qt%E5%B5%8C%E5%85%A5Word/"/>
      <url>/2022/03/24/Qt/Qt%E5%B5%8C%E5%85%A5Word/</url>
      
        <content type="html"><![CDATA[<h2 id="效果">效果</h2><p><img src="/assets/images/Qt-Office-Demo.png" alt="Qt-Office-Demo"></p><h2 id="注册-dsoframer-ocx">注册 dsoframer.ocx</h2><p>前提：需要安装有 Microsoft Word 或者 WPS</p><p>把 dsoframer.ocx 拷贝到系统目录下，并以管理员身份注册：</p><p>32位：</p><blockquote><p>copy dsoframer.ocx c:\windows\system32\dsoframer.ocx<br>regsvr32.exe c:\windows\system32\dsoframer.ocx</p></blockquote><p>64位：</p><blockquote><p>copy dsoframer.ocx c:\windows\SysWOW64\dsoframer.ocx<br>regsvr32.exe c:\windows\SysWOW64\dsoframer.ocx</p></blockquote><p><img src="/assets/images/dsoframer.ocx-reg.png" alt="reg"></p><p><img src="/assets/images/DSOFramerControl-CLSID.png" alt="DSO-CLSID"></p><h2 id="在-QtCreator-中编写测试用例">在 QtCreator 中编写测试用例</h2><p><img src="/assets/images/DSO%20Framer%20Control%20Object.png" alt="DSO Framer Control Object"></p><p>主要代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ui-&gt;axWidget-&gt;<span class="built_in">isNull</span>())</span><br><span class="line">    ui-&gt;axWidget-&gt;<span class="built_in">setControl</span>(<span class="string">&quot;&#123;FBCCBFE5-66FA-4ee3-9AF1-E02A59549AB9&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">ui-&gt;axWidget-&gt;<span class="built_in">setProperty</span>(<span class="string">&quot;Visible&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//    ui-&gt;axWidget-&gt;dynamicCall(&quot;Open(string)&quot;, filePath);</span></span><br><span class="line"></span><br><span class="line">ui-&gt;axWidget-&gt;<span class="built_in">dynamicCall</span>(<span class="string">&quot;createNew(string)&quot;</span>, <span class="string">&quot;Word.Document&quot;</span>); <span class="comment">// 创建空白文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    ui-&gt;axWidget-&gt;dynamicCall(&quot;SetCaption(string)&quot;, &quot;ocx test&quot;); // 设置标题</span></span><br><span class="line">ui-&gt;axWidget-&gt;<span class="built_in">dynamicCall</span>(<span class="string">&quot;SetTitlebar(bool)&quot;</span>, <span class="literal">false</span>); <span class="comment">// 隐藏标题栏</span></span><br><span class="line">ui-&gt;axWidget-&gt;<span class="built_in">dynamicCall</span>(<span class="string">&quot;SetMenuAccelerators(bool)&quot;</span>, <span class="literal">false</span>); <span class="comment">// 菜单快捷键</span></span><br><span class="line">ui-&gt;axWidget-&gt;<span class="built_in">dynamicCall</span>(<span class="string">&quot;SetMenubar(bool)&quot;</span>, <span class="literal">false</span>); <span class="comment">// 隐藏菜单栏</span></span><br><span class="line">ui-&gt;axWidget-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><h2 id="dsoframer-source">dsoframer-source</h2><p><a href="https://github.com/hueidou/DsoFramer">https://github.com/hueidou/DsoFramer</a></p><p><img src="/assets/images/dsoframer-source.png" alt="dsoframer-source"></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QDataStream</title>
      <link href="/2022/03/22/Qt/QDataStream/"/>
      <url>/2022/03/22/Qt/QDataStream/</url>
      
        <content type="html"><![CDATA[<h2 id="QDataStream-writeBytes">QDataStream::writeBytes</h2><blockquote><p>QDataStream &amp;QDataStream::writeBytes(const char *s, uint len)<br>Writes the length specifier len and the buffer s to the stream and returns a reference to the stream.<br>The len is serialized as a quint32, followed by len bytes from s. Note that the data is not encoded.</p></blockquote><p>注意，使用<code>writeBytes</code>函数写的文件，必须用<code>readBytes</code>函数读取，<code>readBytes</code>函数是个工厂函数，会调用<code>new[]</code>分配内存，因此需要调用<code>delete[]</code>进行删除内存，否则会泄露。</p><p>有特殊字符，比如<code>∅ ㎡ 㘵</code>，写入后再次读取，结果乱码。</p><h2 id="QDataStream-writeRawData">QDataStream::writeRawData</h2><blockquote><p>int QDataStream::writeRawData(const char *s, int len)<br>Writes len bytes from s to the stream. Returns the number of bytes actually written, or -1 on error. The data is not encoded.</p></blockquote><p><code>int QDataStream::writeRawData(const char * s, int len)</code>和<code>int QDataStream::readRawData(char * s, int len)</code>函数配对使用，用于写入最原始的内存，如果不想要Qt独有的一些信息，就需要用这两个函数。</p><h2 id="QDataStream">QDataStream&lt;&lt;</h2><blockquote><p>QDataStream &amp;QDataStream::operator&lt;&lt;(Type i)<br>Writes a signed byte, i, to the stream and returns a reference to the stream.</p></blockquote><p>有特殊字符，比如<code>∅ ㎡ 㘵</code>，写入后再次读取，结果正确。</p><h2 id="总结">总结</h2><p>在写出二进制时，如果需要仅仅写入原始的内存，记得使用<code>int QDataStream::writeRawData(const char * s, int len)</code>函数，而不是<code>QDataStream::writeBytes</code>函数！</p><p>有特殊字符，比如<code>∅ ㎡ 㘵</code>，使用<code>QDataStream&lt;&lt;</code></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab 使用教程</title>
      <link href="/2022/03/18/CICD/3.GitLab%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/03/18/CICD/3.GitLab%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建用户">1.创建用户</h2><h3 id="注册用户并添加到组里">注册用户并添加到组里</h3><p>注册新用户后，登录’root’用户，通过 “管理中心” -&gt; “用户” -&gt; “等待批准” 把新用户添加到组里</p><h3 id="新用户添加-SSH-密钥">新用户添加 SSH 密钥</h3><p>登录新用户，把本机的ssh密钥&quot;.ssh/id_rsa.pub&quot;中的内容添加到 “用户设置” -&gt; “SSH密钥”</p><p>然后就可以拉取上传代码了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看公钥</span></span><br><span class="line"><span class="built_in">cat</span> /home/vinda/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="/assets/images/gitlab-add-ssh.png" alt="gitlab-add-ssh"></p><h3 id="创建访问令牌">创建访问令牌</h3><p><img src="/assets/images/Gitlab-access-token.png" alt="Gitlab-access-token"></p><h2 id="2-创建项目">2.创建项目</h2><h2 id="3-修改-GitLab-默认存储位置">3.修改 GitLab 默认存储位置</h2><p><code>GitLab</code> 默认安装时，其默认的仓库存储位置是 <code>/var/opt/gitlab/git-data</code>，用户新建的仓库存储在 <code>repositories</code> 目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">repositories 目录结构树：</span><br><span class="line"></span><br><span class="line">repositories/</span><br><span class="line">├── +gitaly</span><br><span class="line">│   └── tmp</span><br><span class="line">└── @hashed</span><br><span class="line">    ├── 6b</span><br><span class="line">    │   └── 86</span><br><span class="line">    │       ├── 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b.git</span><br><span class="line">    │       │   ├── config</span><br><span class="line">    │       │   ├── HEAD</span><br><span class="line">    │       │   ├── info</span><br><span class="line">    │       │   │   └── refs</span><br><span class="line">    │       │   ├── objects</span><br><span class="line">    │       │   │   ├── info</span><br><span class="line">    │       │   │   │   ├── commit-graphs</span><br><span class="line">    │       │   │   │   │   ├── commit-graph-chain</span><br><span class="line">    │       │   │   │   │   └── graph-27adba23e40056192b87dd4130b04c9297e7a38a.graph</span><br><span class="line">    │       │   │   │   └── packs</span><br><span class="line">    │       │   │   └── pack</span><br><span class="line">    │       │   └── refs</span><br><span class="line">    │       │       ├── heads</span><br><span class="line">    │       │       └── tags</span><br><span class="line">    │       └── 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b.wiki.git</span><br><span class="line">    │           ├── config</span><br><span class="line">    │           ├── HEAD</span><br><span class="line">    │           ├── info</span><br><span class="line">    │           │   └── refs</span><br><span class="line">    │           ├── objects</span><br><span class="line">    │           │   ├── info</span><br><span class="line">    │           │   │   ├── commit-graphs</span><br><span class="line">    │           │   │   │   ├── commit-graph-chain</span><br><span class="line">    │           │   │   │   └── graph-27adba23e40056192b87dd4130b04c9297e7a38a.graph</span><br><span class="line">    │           │   │   └── packs</span><br><span class="line">    │           │   └── pack</span><br><span class="line">    │           └── refs</span><br><span class="line">    │               ├── heads</span><br><span class="line">    │               └── tags</span><br><span class="line">    └── d4</span><br><span class="line">        └── 73</span><br><span class="line">            ├── d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35.git</span><br><span class="line">            │   ......</span><br><span class="line">            └── d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35.wiki.git</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure><p>先把想要存储<code>Gitlab</code>仓库的路径创建好，然后停止<code>Gitlab</code>服务，修改<code>gitlab.rb</code>，迁移已有仓库数据，最后重新配置并启动<code>Gitlab</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Gitlab 仓库的路径</span></span><br><span class="line"><span class="built_in">mkdir</span> -P /home/vinda/Workspace/gitlab-data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 Gitlab 服务</span></span><br><span class="line">sudo gitlab-ctl stop</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 gitlab.rb</span></span><br><span class="line">sudo vi /etc/gitlabe/gitlab.rb</span><br><span class="line"><span class="comment"># 或者用 gedit 打开编辑</span></span><br><span class="line">sudo gedit /etc/gitlabe/gitlab.rb</span><br></pre></td></tr></table></figure><p><img src="/assets/images/gitlab-modify-git_data_dirs.png" alt="gitlab-modify-git_data_dirs"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迁移已有仓库数据</span></span><br><span class="line">rsync -av /var/opt/gitlab/git-data/repositories /home/vinda/Workspace/gitlab-data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新配置并启动`GitLab`</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab + Jenkins 持续集成</title>
      <link href="/2022/03/18/CICD/5.GitLab+Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
      <url>/2022/03/18/CICD/5.GitLab+Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="概述">概述</h2><p><code>Gitlab</code>是一个用于仓库管理系统的开源项目，使用<code>Git</code>作为代码管理工具，并在此基础上搭建起来的<code>Web</code>服务。<br>2022年2月消息，极狐<code>（GitLab）</code>正式宣布推出极狐<code>GitLab SaaS （JihuLab.com）</code>，为中国用户提供从源代码托管到开发运维的全栈式一体化<code>DevOps SaaS</code>平台与企业级专家咨询服务。</p><p><code>Jenkins</code>是一个开源软件项目，是基于<code>Java</code>开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件项目可以进行持续集成。</p><h2 id="配置-GitLab">配置 GitLab</h2><p><img src="/assets/images/jenkins-add-gitlab.png" alt="jenkins-add-gitlab"></p><p><code>API token</code>获取：<a href="./3.GitLab%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.md/#%E5%88%9B%E5%BB%BA%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C">GitLab用户创建访问令牌</a></p><!-- `API token`获取：[GitLab用户创建访问令牌](./3.gitlab使用教程.md/#gitlab使用教程_1.创建用户_创建访问令牌) --><p><img src="/assets/images/jenkins-add-gitlab-api-token.png" alt="jenkins-add-gitlab-api-token"></p><h2 id="配置-Git">配置 Git</h2><p><code>Git</code>的路径可以通过<code>which git</code>获取<br><img src="/assets/images/jenkins-config-git.png" alt="jenkins-config-git"></p><h2 id="新建任务">新建任务</h2><p><img src="/assets/images/jenkins-add-task.png" alt="jenkins-add-task"><br><img src="/assets/images/jenkins-add-task-config-git.png" alt="jenkins-add-task-config-git"><br><img src="/assets/images/jenkins-add-task-config-execute-shell.png" alt="jenkins-add-task-config-execute-shell"></p><h2 id="构建任务">构建任务</h2><p><img src="/assets/images/jenkins-task-build.png" alt="jenkins-task-build"><br><img src="/assets/images/jenkins-task-build-error.png" alt="jenkins-task-build-error"><br><img src="/assets/images/jenkins-task-build-result.png" alt="jenkins-task-build-result"></p>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> GitLab </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins 搭建</title>
      <link href="/2022/03/17/CICD/4.Jenkins%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/03/17/CICD/4.Jenkins%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Jenkins-搭建（Ubuntu-篇）">Jenkins 搭建（Ubuntu 篇）</h2><p>环境：Ubuntu 20.04 LTS</p><h3 id="安装-Jenkins">安装 Jenkins</h3><p><a href="https://pkg.jenkins.io/debian-stable/">Debian Jenkins Packages</a></p><p>This is the Debian package repository of Jenkins to automate installation and upgrade. To use this repository, first add the key to your system:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo <span class="built_in">tee</span> /usr/share/keyrings/jenkins-keyring.asc &gt; /dev/null</span><br></pre></td></tr></table></figure><p>Then add a Jenkins apt repository entry:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/ | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/jenkins.list &gt; /dev/null</span><br></pre></td></tr></table></figure><p>Update your local package index, then finally install Jenkins:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install fontconfig openjdk-11-jre</span><br><span class="line">sudo apt-get install jenkins</span><br></pre></td></tr></table></figure><h3 id="运行-Jenkins">运行 Jenkins</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start jenkins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 jenkins 后，没有任何显示</span></span><br><span class="line"><span class="comment"># 可以使用 status jenkins 查看运行状态</span></span><br><span class="line"></span><br><span class="line">sudo systemctl status jenkins</span><br></pre></td></tr></table></figure><p><img src="/assets/images/jenkins-run-status.png" alt="jenkins-run-status"></p><h3 id="更换国内源">更换国内源</h3><p>更换镜像源为清华源有两种办法：</p><p>1、直接更改default.json</p><p>安装好jenkins后，输完页面密码，这时候jenkins需要的文件目录已经生成完毕了.default.json 是下载安装插件时调用的配置文件，<a href="http://xn--updates-nw3k0j230a22qrfan52qk19b5jwexgb.jenkins.io">其中的下载地址还是updates.jenkins.io</a>，我们需要将其更改为国内的清华源。<br>default.json的具体路劲是：{jenkins的工作路径}/updates/default.json<br>使用sed -i命令将其更换</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/jenkins/updates</span><br><span class="line">sudo sed -i <span class="string">&#x27;s#updates.jenkins.io/download/plugins#mirrors.tuna.tsinghua.edu.cn/jenkins/plugins#g&#x27;</span> default.json &amp;&amp; sudo sed -i <span class="string">&#x27;s#www.google.com#www.baidu.com#g&#x27;</span> default.json</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清华源：http://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</span></span><br><span class="line"></span><br><span class="line">sudo vi /var/lib/jenkins/hudson.model.UpdateCenter.xml</span><br><span class="line">sudo systemctl restart jenkins</span><br></pre></td></tr></table></figure><p>修改完后重启jenkins</p><h3 id="安装插件">安装插件</h3><p><img src="/assets/images/jenkins-plugins.png" alt="jenkins-plugins"><br>如果安装失败，那就再次安装。</p><p>安装中文插件，重启 jenkins ，刷新浏览器，如果不显示中文，则是由于系统语言不是中文的。</p><p>安装<code>Git</code>和<code>GitLab</code>插件，后面使用<code>Jenkins</code>持续集成的时候要用到。</p><h3 id="问题解决-2">问题解决</h3><p>1.Failed to start Jenkins Continuous Integration Server.<br><img src="/assets/images/jenkins-install-error.png" alt="jenkins-install-error"></p><blockquote><p>这是由于内存不足引起的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab 搭建</title>
      <link href="/2022/03/16/CICD/2.GitLab%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/03/16/CICD/2.GitLab%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官方文档：<code>https://about.gitlab.cn/install/</code></p></blockquote><h2 id="GitLab-搭建（Ubuntu-篇）">GitLab 搭建（Ubuntu 篇）</h2><p>环境：Ubuntu 20.04 LTS</p><h3 id="1-安装和配置必须的依赖项">1.安装和配置必须的依赖项</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y curl openssh-server ca-certificates tzdata perl</span><br></pre></td></tr></table></figure><!-- 添加GitLab包存储库curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash --><h3 id="2-下载-GitLab-安装包并安装">2.下载 <code>GitLab</code> 安装包并安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载相应 Ubuntu 版本的安装包</span></span><br><span class="line"><span class="comment"># Ubuntu 16.04 </span></span><br><span class="line">wget https://omnibus.gitlab.cn/ubuntu/xenial/gitlab-jh_14.8.2-jh.0_amd64.deb</span><br><span class="line"><span class="comment"># Ubuntu 18.04 </span></span><br><span class="line">wget https://omnibus.gitlab.cn/ubuntu/bionic/gitlab-jh_14.8.2-jh.0_amd64.deb</span><br><span class="line"><span class="comment"># Ubuntu 20.04 </span></span><br><span class="line">wget https://omnibus.gitlab.cn/ubuntu/focal/gitlab-jh_14.8.2-jh.0_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 777 gitlab-jh_14.8.2-jh.0_amd64.deb</span><br><span class="line">gitlab-jh_14.8.2-jh.0_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line">sudo dpkg -i gitlab-jh_14.8.2-jh.0_amd64.deb</span><br></pre></td></tr></table></figure><h3 id="3-修改-GitLab-默认访问地址">3.修改 <code>GitLab</code> 默认访问地址</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">// 将external_url  地址改成本地</span><br><span class="line">// external_url <span class="string">&#x27;http://localhost&#x27;</span> <span class="comment"># 默认端口是 80</span></span><br></pre></td></tr></table></figure><p><img src="/assets/images/gitlab-modify-port.png" alt="gitlab-modify-port"></p><p>查看 <code>GitLab</code> 配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</span><br></pre></td></tr></table></figure><p><img src="/assets/images/gitlab-cat-port.png" alt="gitlab-cat-port"></p><h3 id="4-更新配置">4.更新配置</h3><p>这个过程会比较久</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><h3 id="5-启动-GitLab">5.启动 GitLab</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure><p>在本机打开浏览器输入 ‘localhost’，或者在另外电脑的浏览器输入服务机的 <code>IP</code><br><img src="/assets/images/gitlab-welcome.png" alt="gitlab-welcome"></p><h3 id="6-root-用户">6.root 用户</h3><p><code>GitLab</code> 默认有了<code>root</code>用户，其密码可以通过<code>/etc/gitlab/initial_root_password</code>得知，这个文件只保存24小时</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure><p><img src="/assets/images/gitlab-initial-root-password.png" alt="gitlab-initial-root-password"></p><p>这个密码比较复制，可以修改成我们比较容易记忆的密码</p><p><img src="/assets/images/gitlab-reset-password.png" alt="gitlab-reset-password"></p><h3 id="测试">测试</h3><p>在本机打开浏览器输入<code>localhost</code>，使用刚才修改号的密码登录<code>root</code>用户。</p><h3 id="问题解决">问题解决</h3><p>1.访问比较缓慢</p><blockquote><p>GitLab 对于机器性能的要求不低，镜像就有一个多G，每次启动容器，重启，需要花一段时间等待。</p></blockquote><p>2.访问还是502</p><blockquote><p>看看CPU占用率，电脑容量，有些情况是因为CPU、内存耗尽导致</p></blockquote><p>3.访问网址</p><blockquote><p>是<code>http</code>而不是<code>https</code></p></blockquote><p>4.网页端操作失败（无响应）</p><blockquote><p>在服务端操作后，到网页端操作，如有失败的情况，需要稍等片刻，等服务端反应过来（机器性能差）或者通过 <code>gitlab-ctl status</code> 查看一下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 CI/CD</title>
      <link href="/2022/03/16/CICD/1.%E4%BB%80%E4%B9%88%E6%98%AFCICD/"/>
      <url>/2022/03/16/CICD/1.%E4%BB%80%E4%B9%88%E6%98%AFCICD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<code>https://dzone.com/articles/what-is-cicd</code><br>译文：<code>https://blog.csdn.net/weixin_44903147/article/details/96291588</code></p></blockquote><h2 id="一、简介">一、简介</h2><p>CI / CD的采用改变了开发人员和测试人员如何发布软件。<br><img src="/assets/images/cicd-1.png" alt="DevOps"><br>最初是瀑布模型，后来是敏捷开发，现在是DevOps，这是现代开发人员构建出色的产品的技术路线。随着DevOps的兴起，出现了持续集成（Continuous Integration）、持续交付（Continuous Delivery） 、持续部署（Continuous Deployment） 的新方法。传统的软件开发和交付方法正在迅速变得过时。从历史上看，在敏捷时代，大多数公司会每月，每季度，每两年甚至每年发布部署/发布软件。然而，现在是 <a href="https://aws.amazon.com/cn/devops/what-is-devops/">DevOps</a> 时代，每周，每天，甚至每天多次是常态。当SaaS正在占领世界时，尤其如此，您可以轻松地动态更新应用程序，而无需强迫客户下载新组件。很多时候，他们甚至都不会意识到正在发生变化。开发团队通过软件交付流水线（Pipeline）实现自动化，以缩短交付周期，大多数团队都有自动化流程来检查代码并部署到新环境。今天，我们将介绍什么是CI / CD / CD，以及现代软件公司如何使用工具将部署代码的流程自动化。<br>持续集成的重点是将各个开发人员的工作集合到一个代码仓库中。通常，每天都要进行几次，主要目的是尽早发现集成错误，使团队更加紧密结合，更好地协作。<br>持续交付的目的是最小化部署或释放过程中固有的摩擦。它的实现通常能够将构建部署的每个步骤自动化，以便任何时刻能够安全地完成代码发布（理想情况下）。<br>持续部署是一种更高程度的自动化，无论何时对代码进行重大更改，都会自动进行构建/部署。<br>这些阶段中的每一个都是交付管道的一部分 。在Humble和Farley的书《持续交付：可靠的软件版本中，通过构建，测试和部署自动化》，解释“对软件的每次更改，都会在发布过程中经历一个复杂的过程。该过程涉及构建软件，然后通过多个测试和部署阶段进行这些构建。反过来，这需要许多人之间的合作，也许需要几个团队之间的合作。部署管道对此过程进行建模，并且它在持续集成和发布管理工具中的实现，使您能够在从版本控制转移到各种测试和部署，以向用户发布时查看和控制每个更改的进度。”<br><img src="/assets/images/cicd-2.png" alt="软件交付流水线"></p><h2 id="二、持续集成（CI）">二、持续集成（CI）</h2><p>通过持续集成，开发人员能够频繁将其代码集成到公共代码仓库的主分支中。开开发人员能够在任何时候多次向仓库提交作品，而不是独立地开发每个功能模块并在开发周期结束时一一提交。<br>这里的一个重要想法是让开发人员更快，更频繁地做到这一点，从而降低集成成本。实际情况中，开发人员在集成时经常会发现新代码和已有代码存在冲突。如果集成较早并更加频繁，那么冲突将更容易解决且执行成本更低。当然，还有一些权衡。此流程变更不提供任何额外的质量保证。实际上，许多组织发现这种集成变得更加昂贵，因为它们依赖于手动过程来确保新代码不会引入新的错误，并且不会破坏现有代码。为了减少集成任务期间的摩擦，持续集成依赖于测试套件和自动化测试执行。然而，要认识到自动化测试和持续测试是完全不同的这一点很重要，我们会在文章结尾处详细说明。<br>CI 的目标是将集成简化成一个简单、易于重复的日常开发任务，这将有助于降低总体构建成本，并在周期的早期发现缺陷。要想有效地使用 CI 必须转变开发团队的习惯，要鼓励频繁迭代构建，并且在发现 bug 的早期积极解决。</p><h2 id="三、持续交付（CD）">三、持续交付（CD）</h2><p>实际上是 CI 的扩展，其中软件交付流程进一步自动化，以便随时轻松地部署到生成环境中。CD 集中依赖于部署流水线，团队通过流水线自动化测试和部署过程。此流水线是一个自动化系统，可以针对构建执行一组渐进的测试套件。CD 具有高度的自动化，并且在一些云计算环境中也易于配置。在流水线的每个阶段，如果构建无法通过关键测试会向团队发出警报。否则，将继续进入下一个测试，并在连续通过测试后自动进入下一个阶段。流水线的最后一个部分会将构建部署到和生产环境等效的环境中。这是一个整体的过程，因为构建、部署和环境都是一起执行和测试的，它能让构建在实际的生产环境可部署和可验证。<br>AWS上提供了现代CI / CD管道的可靠展示。亚马逊是云计算提供商之一，提供令人印象深刻的CI / CD 管道环境，并提供一个演练过程，您可以从其中选择众多开发资源，并将它们链接在一个易于配置且易于监控的管道中。<br><img src="/assets/images/cicd-3.png" alt="AWS-CI/CD管道"><br>许多人认为持续交付的吸引力主要在于，它自动化了从提交代码到仓库，再到测试和发布产品过程的所有步骤。这是构建和测试过程细致的自动化，但是如何发布以及发布什么仍然是需要人工操作，持续部署可以改变这一点。</p><h2 id="四、持续部署（CD）">四、持续部署（CD）</h2><p>持续部署扩展了持续交付，以便软件构建，在通过所有测试时自动部署。在这样的流程中，不需要人为决定何时及如何投入生产环境。CI/CD 系统的最后一步将在构建后的组件/包退出流水线时自动部署。此类自动部署可以配置为快速向客户分发组件、功能模块或修复补丁，并准确说明当前提供的内容。<br>采用持续部署的组织可以将新功能快速传递给用户，得到用户对于新版本的快速反馈，并且可以迅速处理任何明显的缺陷。用户对无用或者误解需求的功能的快速反馈有助于团队规划投入，避免将精力集中于不容易产生回报的地方。随着 DevOps 的发展，新的用来实现 CI/CD 流水线的自动化工具也在不断涌现。这些工具通常能与各种开发工具配合，包括像 GitHub 这样的代码仓库和 Jira 这样的 bug 跟踪工具。此外，随着 SaaS 这种交付方式变得更受欢迎，许多工具都可以在现代开发人员运行应用程序的云环境中运行，例如 GCP 和 AWS。最受欢迎的自动化工具是 Jenkins（以前的 Hudson），这是一个由数百名贡献者和商业公司 Cloudbees 支持的开源项目。Cloudbees 甚至聘请了 Jenkins 的创始人，并提供了一些 Jenkins 培训项目和附加组件。除了开源项目之外，还有一些更现代化的商业产品例如 CircleCI，Codeship 和 Shippable。这些产品各有优缺点，我鼓励开发人员在开发流程中一一尝试它们，以了解它们在您的环境中的工作方式，以及它们如何与您的工具、云平台、容器系统等协作。</p><h2 id="五、下一步是什么？">五、下一步是什么？</h2><p>一旦部署了现代化的 CI/CD 流水线，您可能会意识到开发人员工作流程中的一些工具和流程也需要进行现代化改造。测试是一个要着重关注的领域，如果您的部署频率是每天或者一天多次，您的每次测试可能需要数小时甚至一晚上才能完成。mabl 正在使用机器学习解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt问题-Qt-connect-没有调用槽函数</title>
      <link href="/2022/03/07/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-Qt-connect-%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%A7%BD%E5%87%BD%E6%95%B0/"/>
      <url>/2022/03/07/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-Qt-connect-%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%A7%BD%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>Qt connect 自定义类型要注册<br><img src="/assets/images/QtProblems-qt-connect-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%A6%81%E6%B3%A8%E5%86%8C.png" alt="qt-connect-自定义类型要注册"></p>]]></content>
      
      
      <categories>
          
          <category> QtProblems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtProblems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt问题-QSettings读取注册表</title>
      <link href="/2022/02/17/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-QSettings%E8%AF%BB%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
      <url>/2022/02/17/Qt/QtProblems/Qt%E9%97%AE%E9%A2%98-QSettings%E8%AF%BB%E5%8F%96%E6%B3%A8%E5%86%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p><code>QSettings</code>在<code>32-bit</code>程序中访问&quot;\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall&quot;是可以的，<br>但是访问不了&quot;\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall&quot;，<br>在<code>64-bit</code>程序中访问上面的都可以。</p><h2 id="问题分析">问题分析</h2><p>1<br>在<code>Microsoft</code>文档中有相关说明：<a href="https://docs.microsoft.com/zh-cn/windows/win32/winprog64/accessing-an-alternate-registry-view?redirectedfrom=MSDN">访问备用注册表视图</a></p><p><img src="/assets/images/QtProblems-%E8%AE%BF%E9%97%AE%E5%A4%87%E7%94%A8%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%A7%86%E5%9B%BE.png" alt="访问备用注册表视图"></p><p>2<br>QSetting访问注册表问题<br>发现这两个注册表节点<br>“\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall”<br>“\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall”<br>在QSetting加载第一个节点时，会自动重定向到第二个上面<br>有什么办法正确的访问第一个吗<br>Win10</p><p>用win api关闭重定向即可，操作前关闭，操作后恢复</p><p>64位系统下的32位程序是这样的<br>除非你是多个程序配合开发，否则不建议改</p><h2 id="问题解决-3">问题解决</h2><p>在QT下使用msvc或minGW时记得在<code>pro</code>中添加：<code>LIBS += -lsetupapi -ladvapi32</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> QString REG_UNINSTALL             = <span class="string">R&quot;(Software\Microsoft\Windows\CurrentVersion\Uninstall\xx)&quot;</span>;</span><br><span class="line"><span class="type">const</span> QString REG_WOW6432Node_UNINSTALL = <span class="string">R&quot;(Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\xx)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> strSubKeys = &#123; REG_WOW6432Node_UNINSTALL, REG_UNINSTALL &#125;;</span><br><span class="line">HKEY hKey = HKEY_LOCAL_MACHINE;</span><br><span class="line">REGSAM samDesired = KEY_ALL_ACCESS;</span><br><span class="line"><span class="keyword">if</span> (strSubKey.<span class="built_in">contains</span>(<span class="string">&quot;WOW6432Node&quot;</span>, Qt::CaseInsensitive)) &#123;</span><br><span class="line">    samDesired |= KEY_WOW64_32KEY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    samDesired |= KEY_WOW64_64KEY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RegOpenKeyExA</span>(hKey, strSubKey.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>(), <span class="literal">NULL</span>, samDesired, &amp;hKey) == ERROR_SUCCESS) &#123;</span><br><span class="line">    DWORD dwSize;</span><br><span class="line">    dwSize = <span class="built_in">sizeof</span>(tchDataDisplayicon);</span><br><span class="line">    <span class="built_in">RegQueryValueExA</span>(hKey, REG_DISPLAYICON, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPBYTE)tchDataDisplayicon, &amp;dwSize);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; strSubKey &lt;&lt; QString::<span class="built_in">fromLocal8Bit</span>(tchDataDisplayicon);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> QtProblems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtProblems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tdesktop 源码初探</title>
      <link href="/2022/01/25/OpenSourceProjects/tdesktop/tdesktop-3-%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/01/25/OpenSourceProjects/tdesktop/tdesktop-3-%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>折腾一番后。。。</p><p><img src="/assets/images/tdesktop-rpl.png" alt="tdesktop-rpl"></p><p>直接放弃了。</p>]]></content>
      
      
      <categories>
          
          <category> tdesktop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> tdesktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tdesktop 编译</title>
      <link href="/2022/01/21/OpenSourceProjects/tdesktop/tdesktop-1-%E7%BC%96%E8%AF%91/"/>
      <url>/2022/01/21/OpenSourceProjects/tdesktop/tdesktop-1-%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><code>tdesktop</code> 的 <code>github</code> 上有介绍编译步骤：<a href="https://github.com/telegramdesktop/tdesktop/blob/dev/docs/building-win-x64.md">tdesktop-building-win-x64</a></p><p>Choose an empty folder for the future build, for example <code>D:\TBuild</code>. It will be named <code>BuildPath</code> in the rest of this document. Create two folders there, <code>BuildPath\ThirdParty</code> and <code>BuildPath\Libraries</code>.<br><img src="/assets/images/tdesktop-build-folder.png" alt="tdesktop-build-folder"></p><p>按照官方文档把所需要的第三方软件安装到对应的位置</p><!-- ![tdesktop-build-install-third-party-software](/assets/images/tdesktop-build-install-third-party-software.png) --><p>Download Strawberry Perl installer from <a href="http://strawberryperl.com/">http://strawberryperl.com/</a> and install to BuildPath\ThirdParty\Strawberry<br>Download NASM installer from <a href="http://www.nasm.us">http://www.nasm.us</a> and install to BuildPath\ThirdParty\NASM<br>Download Yasm executable from <a href="http://yasm.tortall.net/Download.html">http://yasm.tortall.net/Download.html</a>, rename to yasm.exe and put to BuildPath\ThirdParty\yasm<br>Download MSYS2 installer from <a href="http://www.msys2.org/">http://www.msys2.org/</a> and install to BuildPath\ThirdParty\msys64<br>Download jom archive from <a href="http://download.qt.io/official_releases/jom/jom.zip">http://download.qt.io/official_releases/jom/jom.zip</a> and unpack to BuildPath\ThirdParty\jom<br>Download Python 3.9 installer from <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a> and install to BuildPath\ThirdParty\Python39<br>Download CMake 3.21 or later installer from <a href="https://cmake.org/download/">https://cmake.org/download/</a> and install to BuildPath\ThirdParty\cmake<br>Download Ninja executable from <a href="https://github.com/ninja-build/ninja/releases/download/v1.7.2/ninja-win.zip">https://github.com/ninja-build/ninja/releases/download/v1.7.2/ninja-win.zip</a> and unpack to BuildPath\ThirdParty\Ninja<br>Download Git installer from <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> and install it.<br>Download NuGet executable from <a href="https://dist.nuget.org/win-x86-commandline/latest/nuget.exe">https://dist.nuget.org/win-x86-commandline/latest/nuget.exe</a> and put to BuildPath\ThirdParty\NuGet</p><p>Add Python 3.9 and NuGet to your PATH:</p><p>Open Control Panel -&gt; System -&gt; Advanced system settings.<br>Press Environment Variables…<br>Select Path.<br>Press Edit.<br>Add <code>BuildPath\ThirdParty\Python39</code> value.<br>Add <code>BuildPath\ThirdParty\NuGet</code> value.</p><p><a href="./tdesktop-thirdparty-software.zip">所需要的第三方软件打包</a></p><p><img src="/assets/images/tdesktop-build-tool.png" alt="tdesktop-build-tool"></p><p><code>tdesktop</code>最新的源码编译工具是使用<code>vs2022</code>，可以下载安装社区版<br>打开<code>vs2022 x64</code>命令行窗口<br><img src="/assets/images/tdesktop-build-vs2022.png" alt="tdesktop-build-vs2022"></p><p>Open x64 Native Tools Command Prompt for VS 2022.bat, go to <code>BuildPath</code> and run</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install pywin32</span><br></pre></td></tr></table></figure><p>Clone source code and prepare libraries<br>Open <code>x64 Native Tools Command Prompt for VS 2022.bat</code>, go to <code>BuildPath</code> and run</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/telegramdesktop/tdesktop.git</span><br><span class="line">tdesktop\Telegram\build\prepare\win.bat</span><br></pre></td></tr></table></figure><blockquote><p>注意: 这里克隆子目录有可能会失败，可以到<code>tdesktop-github-tree</code>打开对应的仓库自行下载并切换到指定的提交</p></blockquote><p>这里的每个库都要安装编译成功<br><img src="/assets/images/tdesktop-build.png" alt="tdesktop-build"></p><p>如果没有梯子，可以通过修改<code>prepare.py</code>脚本解决<br>打开<code>\BuildPath\tdesktop\Telegram\build\prepare\prepare.py</code>把无法下载的仓库地址替换成<code>github</code>上对应的仓库<br><a href="./prepare-modify-for-git.py">prepare-modify-for-git.py</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure.bat x64 -D TDESKTOP_API_ID=17349 -D TDESKTOP_API_HASH=344583e45741c457fe1862106095a5eb -D DESKTOP_APP_USE_PACKAGED=OFF -D DESKTOP_APP_DISABLE_CRASH_REPORTS=OFF</span><br></pre></td></tr></table></figure><p>对应的 api 在这里 <a href="https://github.com/telegramdesktop/tdesktop/blob/dev/docs/api_credentials.md">tdesktop-api_credentials</a></p><h2 id="结果">结果</h2><p><img src="/assets/images/tdesktop-sln.png" alt="tdesktop-sln"><br><img src="/assets/images/tdesktop-vs2022.png" alt="images/tdesktop-vs2022"><br><img src="/assets/images/result.png" alt="tdesktop-result"></p><p>为了更好的调试，可以在<code>vs2022</code>安装<code>Qt Visual Studio Tools</code>扩展<br>Qt Visual Studio Tools<br>For better debugging you may want to install Qt Visual Studio Tools:</p><p>Open Extensions -&gt; Manage Extensions<br>Go to Online tab<br>Search for Qt<br>Install Qt Visual Studio Tools extension</p><h2 id="问题-2">问题</h2><p>1.安装 MSYS2<br><img src="/assets/images/msys2-updating-trust-database.png" alt="msys2-updating-trust-database"></p><p>2.安装Python<br><img src="/assets/images/No%20python%20installation%20was%20detected.png" alt="No python installation was detectedNo python installation was detected"></p><p>3.vs-error-C2220<br><img src="/assets/images/vs-error-C2220.png" alt="vs-error-C2220"></p>]]></content>
      
      
      <categories>
          
          <category> tdesktop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> tdesktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Q_D指针</title>
      <link href="/2022/01/13/Qt/Q_D%E6%8C%87%E9%92%88/"/>
      <url>/2022/01/13/Qt/Q_D%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：[<a href="https://wiki.qt.io/D-Pointer/zh">https://wiki.qt.io/D-Pointer/zh</a>]</p></blockquote><h2 id="什么是-d-pointer">什么是 d-pointer</h2><p>如果你曾经查看过Qt的源代码文件，例如 <a href="http://qt.gitorious.com/qt/qt/blobs/master/src/gui/widgets/qlabel.cpp">这个</a> <code>Q_D</code> 和 <code>Q_Q</code> 宏定义。本文就来揭开这些宏使用的目的。</p><p><code>Q_D</code> 和 <code>Q_Q</code> 宏定义是d-pointer(也被称为 <a href="http://en.wikipedia.org/wiki/Opaque_pointer">opaque pointer</a>)设计模式的一部分, 它可以把一个类库的实施细节对使用的用户隐藏， 而且对实施的更改不会打破二进制兼容。</p><h2 id="什么是二进制兼容">什么是二进制兼容</h2><p>在设计像 Qt 这样的类库的时候，理想的行为应该是动态连接到 Qt 的应用程序，甚至在 Qt 类库升级或者替换到另外一个版本的时候，不需要重新编译就可以继续运行。例如，你的应用程序 <em>CuteApp</em> 是基于 Qt 4.5 的，你应该可以把你的 Qt 由4.5升级到 Qt 4.6 （在 Windows 下用安装程序，在 Linux 下通常有包管理器自动完成），而你用 Qt 4.5 构建的 CuteApp 应该还可以运行。</p><h2 id="什么会打破二进制兼容">什么会打破二进制兼容</h2><p>那么，什么时候类库的变化需要应用程序的重新编译呢？ 我们来看一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Rect m_geometry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Label</span> : <span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="function">String <span class="title">text</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_text; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，我们有一个 Widget， 包含一个 geometry 作为成员变量。 我们编译 Widget 并且发布为 <em><strong>WidgetLib 1.0</strong></em>。</p><p>对于 <em><strong>WidgetLib 1.1</strong></em> ， 有人有了新的主意要添加样式表支持。没问题，我们只需要添加一个新的方法和一个新的 <em>数据成员</em>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Rect m_geometry;</span><br><span class="line">String m_stylesheet; <span class="comment">// NEW in WidgetLib 1.1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Label</span> : <span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">String <span class="title">text</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_text; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们发布 WidgetLib 1.1，仅仅包含上面的变化，却发现和 WidgetLib 1.0一起编译并且运行正常的 CuteApp 光荣地崩溃了！</p><h2 id="为什么会崩溃">为什么会崩溃</h2><p>究其原因，通过添加了一个新的数据成员，我们最终改变了 <code>Widget</code> 和 <code>Label</code> 对象的大小。为什么会这样？因为当你的C++编译器生成代码的时候，他会用<code>偏移量</code>来访问对象的数据。</p><p>下面是一个 POD 对象在内存里面布局的一个简化版本。</p><table><thead><tr><th style="text-align:center"><code>Label 对象在 WidgetLib 1.0的布局</code></th><th style="text-align:center"><code>Label 对象在 WidgetLib 1.1的布局</code></th></tr></thead><tbody><tr><td style="text-align:center">m_geometry &lt;偏移量 0&gt;</td><td style="text-align:center">m_geometry &lt;偏移量 0&gt;</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">m_stylesheet &lt;偏移量 1&gt;</td></tr><tr><td style="text-align:center">m_text &lt;偏移量 1&gt;</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">m_text &lt;偏移量 2&gt;</td></tr></tbody></table><p>在 WidgetLib 1.0中，Label 的 text 成员在（逻辑）偏移量为1的位置。在编译器生成的代码里，应用程序的方法 <code>Label::text()</code> 被翻译成访问 Label 对象里面偏移量为1的位置。<br>在 WidgetLib 1.1中，Label 的 text 成员的（逻辑）偏移量被转移到了2的位置！由于应用程序没有重新编译，它仍然认为 <code>text</code> 在偏移量1的位置，结果却访问了 <code>stylesheet</code> 变量！</p><p>我确信，这个时候，会有人问，为什么<code>Label::text()</code>的偏移量的计算的代码会在CuteApp二进制文件结束，而不是在WidgetLib的二进制文件。 答案是因为<code>Label::text()</code> 的代码定义在头文件里面，最终被<a href="http://en.wikipedia.org/wiki/Inline_function">内联</a>。</p><p>那么，如果 <code>Label::text()</code> 没有定义为内联函数，情况会改变吗？这么讲，<code>Label::text()</code> 被移到源文件里面？嗯，不会。C编译器依赖对象大小在编译时和运行时相同。比如，堆栈的 winding/unwinding - 如果你在堆栈上创建了一个 Label 对象， 编译器产生的代码会根据 Label 对象在编译时的大小在堆栈上分配空间。由于Label的大小在 WidgetLib 1.1 运行时已经不同，Label 的构造函数会覆盖已经存在的堆栈数据，最终破坏堆栈。</p><h2 id="不要改变导出的-C-类的大小">不要改变导出的 C++ 类的大小</h2><p>总之，一旦你的类库发布了，永远不要改变 <em>导出的</em> C++ 类的大小或者布局（不要移动成员）。C++ 编译器生成的代码会假定，一个类的大小和成员的顺序 <em>编译后</em> 就不会改变.</p><p>那么，如何在不改变对象的大小的同时添加新的功能呢？</p><h2 id="d-pointer">d-pointer</h2><p>诀窍是通过保存唯一的一个指针而保持一个类库所有公共类的大小不变。这个指针指向一个包含所有数据的私有的（内部的）数据结构。内部结构的大小可以增大或者减小，而不会对应用程序带来副作用，因为指针只会被类库里面的代码访问，从应用程序的视角来看，对象的大小并没有改变 - 它永远是指针的大小。 这个指针被叫做 <em>d-pointer</em> 。</p><p>这个模式的精髓可以由下面的代码来概述（本文中的所有代码都没有析构函数，在实际使用的时候应该加上它）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* widget.h */</span></span><br><span class="line"><span class="comment">// 前置声明. 定义在 widget.cpp 或者</span></span><br><span class="line"><span class="comment">// 单独的一个文件，比如 widget_p.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetPrivate</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="function">Rect <span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// d-pointer never referenced in header file.</span></span><br><span class="line"><span class="comment">// Since WidgetPrivate is not defined in this header,</span></span><br><span class="line"><span class="comment">// any access will be a compile error</span></span><br><span class="line">WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* widget_p.h */</span> (_p 意味着私有)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WidgetPrivate</span> &#123;</span><br><span class="line">Rect geometry;</span><br><span class="line">String stylesheet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* widget.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget_p.h&quot;</span></span></span><br><span class="line">Widget::<span class="built_in">Widget</span>()</span><br><span class="line">: <span class="built_in">d_ptr</span>(<span class="keyword">new</span> WidgetPrivate) &#123;</span><br><span class="line"><span class="comment">// 创建私有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">Widget::geoemtry</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// d-ptr 仅仅被类库代码访问</span></span><br><span class="line"><span class="keyword">return</span> d_ptr-&gt;geometry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* label.h */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Label</span> : <span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="function">String <span class="title">text</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 每个类维护自己的 d-pointer</span></span><br><span class="line">LabelPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* label.cpp */</span></span><br><span class="line"><span class="comment">// 和 WidgetPrivate 不同, 我们在它自己的源文件里定义 LabelPrivate</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LabelPrivate</span> &#123;</span><br><span class="line">String text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::<span class="built_in">Label</span>()</span><br><span class="line">: <span class="built_in">d_ptr</span>(<span class="keyword">new</span> LabelPrivate) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">Label::text</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> d_ptr-&gt;text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的机构，CuteApp 从来不需要直接访问 d-pointer。由于 <em>d-pointer</em> 只是在 WidgetLib 被访问，而 WidgetLib 在每一次发布都被重新编译，私有的类可以随意的改变而不会对 CuteApp 带来影响。</p><h2 id="d-pointer-的其它好处">d-pointer 的其它好处</h2><p>这里不全都是和二进制兼容有关。d-pointer 还有其它的好处：</p><ul><li>隐藏了实现细节 - 我们可以只发布带有头文件和二进制文件的 WidgetLib。源文件可以是闭源代码的。</li><li>头文件很干净，不包含实现细节，可以直接作为 API 参考。</li><li>由于实施需要的包含的头文件从头文件里已到了实施（源文件）里面，编译速更快。（译：降低了编译依赖）</li></ul><p>事实上，上边的好处是微乎其微的。Qt 使用 d-pointer 的真正原因是为了二进制兼容和 Qt 最初是封闭源代码的.（译：Qt 好像没有封闭源代码）</p><h2 id="q-pointer">q-pointer</h2><p>到目前为止，我们仅仅看到的是作为 C 风格的数据机构的 d-pointer。实际上，它可以包含私有的方法（辅助函数）。例如，<code>LabelPrivate</code> 可以有一个<code>getLinkTargetFromPoint()</code> 辅助函数，当鼠标点击的时候找到目标链接。在很多情况下，这些辅助函数需要访问公有类，也就是 Label 或者它的父类 Widget 的一些函数。比如，一个辅助函数 <code>setTextAndUpdateWidget()</code> 想要调用一个安排重画Widget的公有方法 <code>Widget::update()</code>。所以，<code>WidgetPrivate</code> 存储了一个指向公有类的指针，称为q-pointer。修改上边的代码引入q-pointer，我们得到下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* widget.h */</span></span><br><span class="line"><span class="comment">// 前置声明. 定义在 widget.cpp</span></span><br><span class="line"><span class="comment">// 或者单独的一个文件，比如 widget_p.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetPrivate</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">…</span><br><span class="line"><span class="function">Rect <span class="title">geometry</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// d-pointer 从来不在头文件被引用</span></span><br><span class="line"><span class="comment">// 因为WidgetPrivate没有在头文件里定义,</span></span><br><span class="line"><span class="comment">// 所有对它的访问都会带来编译错误</span></span><br><span class="line">WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* widget_p.h */</span> (_p意味着私有)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WidgetPrivate</span> &#123;</span><br><span class="line"><span class="comment">// constructor that initializes the q-ptr</span></span><br><span class="line"><span class="built_in">WidgetPrivate</span>(Widget *q) : <span class="built_in">q_ptr</span>(q) &#123; &#125;</span><br><span class="line">Widget *q_ptr; <span class="comment">// q-ptr that points to the API class</span></span><br><span class="line">Rect geometry;</span><br><span class="line">String stylesheet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* widget.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget_p.h&quot;</span></span></span><br><span class="line"><span class="comment">// create private data. pass the &#x27;this&#x27; pointer to initialize the q-ptr</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>()</span><br><span class="line">: <span class="built_in">d_ptr</span>(<span class="keyword">new</span> <span class="built_in">WidgetPrivate</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">Widget::geoemtry</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">// the d-ptr is only accessed in the library code</span></span><br><span class="line"><span class="keyword">return</span> d_ptr-&gt;geometry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* label.h */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Label</span> : <span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="function">String <span class="title">text</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">LabelPrivate *d_ptr; <span class="comment">// each class maitains it&#x27;s own d-pointer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* label.cpp */</span></span><br><span class="line"><span class="comment">// Unlike WidgetPrivate, we define LabelPrivate in the source file</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LabelPrivate</span> &#123;</span><br><span class="line"><span class="built_in">LabelPrivate</span>(Label *q) : <span class="built_in">q_ptr</span>(q) &#123; &#125;</span><br><span class="line">Label *q_ptr;</span><br><span class="line">String text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::<span class="built_in">Label</span>()</span><br><span class="line">: <span class="built_in">d_ptr</span>(<span class="keyword">new</span> <span class="built_in">LabelPrivate</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">Label::text</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> d_ptr-&gt;text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进一步优化">进一步优化</h2><p>对于上边的代码，创建一个 Label 会带来 <code>LabelPrivate</code> 和 <code>WidgetPrivate</code> 的内存分配。如果我们在Qt里面采用这种策略，对已一些像 <code>QListWidget</code> 的类，情况会相当糟糕 - 它有6层的继承层次，也就会带来最多6次的内存分配。</p><p>通过对我们的 <em>私有</em> 类添加一个继承层次，解决了这个问题，这样类实例化时将一个 d-pointer 层层向上传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* widget.h */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// only sublasses may access the below</span></span><br><span class="line"><span class="built_in">Widget</span>(WidgetPrivate &amp;d); <span class="comment">// 允许子类通过他们自己的实体私有对象来初始化</span></span><br><span class="line">WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* widget_p.h */</span> (_p means <span class="keyword">private</span>)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WidgetPrivate</span> &#123;</span><br><span class="line"><span class="built_in">WidgetPrivate</span>(Widget *q) : <span class="built_in">q_ptr</span>(q) &#123; &#125; <span class="comment">// 构造函数初始化 q-ptr</span></span><br><span class="line">Widget *q_ptr; <span class="comment">// 指向API类的</span></span><br><span class="line">Rect geometry;</span><br><span class="line">String stylesheet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* widget.cpp */</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>()</span><br><span class="line">: <span class="built_in">d_ptr</span>(<span class="keyword">new</span> <span class="built_in">WidgetPrivate</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(WidgetPrivate &amp;d)</span><br><span class="line">: <span class="built_in">d_ptr</span>(&amp;d) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* label.h */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Label</span> : <span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Label</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">Label</span>(LabelPrivate &amp;d); <span class="comment">// 允许Label的子类传递自己的私有数据</span></span><br><span class="line"><span class="comment">//注意 Label 没有 d_ptr！它用了父类 Widget 的 d_ptr。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget_p.h&quot;</span> <span class="comment">// 所以我们能够访问 WidgetPrivate</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LabelPrivate</span> : <span class="keyword">public</span> WidgetPrivate &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::<span class="built_in">Label</span>() : <span class="built_in">Widget</span>(*<span class="keyword">new</span> LabelPrivate) &#123;</span><br><span class="line"> <span class="comment">// 用我们自己的私有对象来初始化 d-pointer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Label::<span class="built_in">Label</span>(LabelPrivate &amp;d) : <span class="built_in">Widget</span>(d) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很漂亮？现在当我们创建一个 <code>Label</code> 对象时，它会创建一个 <code>LabelPrivate</code>（它继承了 <code>WidgetPrivate</code>）。它把一个 <em>d-pointer</em> 实体传递给Widget的保护的构造函数。Label 也有这样一个保护的构造函数，可以被继承 <code>Label</code> 的类提供自己的私有类来使用。</p><h2 id="把-q-ptr-和-d-ptr-转型到正确的类型（QPTR-和-DPTR）">把 q-ptr 和 d-ptr 转型到正确的类型（QPTR 和 DPTR）</h2><p>上一步优化的一个副作用是 q-ptr 和 d-ptr 的类型分别是 <code>Widget</code> 和 <code>WidgetPrivate</code>。<br>这就意味着下面的代码不能工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Label::setText</span><span class="params">(<span class="type">const</span> String &amp;text)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 不工作。虽然 d_ptr 指向 LabelPrivate 对象，但是它是 WidgetPrivate 类型</span></span><br><span class="line">d_ptr-&gt;text = text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在子类里访问 d-pointer 的时候，需要用 static_cast 转型到合适的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Label::setText</span><span class="params">(<span class="type">const</span> String &amp;text)</span> </span>&#123;</span><br><span class="line">LabelPrivate *d = <span class="built_in">static_cast</span>&lt;LabelPrivate*&gt;(d_ptr); <span class="comment">// cast to our private type</span></span><br><span class="line">d-&gt;text = text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里到处都是 static_cast 看起来不是那么漂亮，所以我们定义了下面的宏，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global.h (macros)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DPTR (Class) Class##Private *d = static_cast<span class="string">&lt;Class##Private*&gt;</span>(d_ptr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QPTR (Class) Class *q = static_cast<span class="string">&lt;Class*&gt;</span>(q_ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// label.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Label::setText</span><span class="params">(<span class="type">const</span> String &amp;text)</span> </span>&#123;</span><br><span class="line"><span class="built_in">DPTR</span> (Label);</span><br><span class="line">d-&gt;text = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LabelPrivate::someHelperFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">QPTR</span> (label);</span><br><span class="line">q-&gt;<span class="built_in">selectAll</span>(); <span class="comment">// we can call functions in Label now</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Qt-中的-d-pointers">Qt 中的 d-pointers</h2><p>在 Qt 中，几乎所有的公有类都使用了 d-pointer。唯一不用的情况是如果事先知道某个类永远不会添加额外的成员变量。例如，像 <code>QPoint</code>, <code>QRect</code> 这些类，我们不期望有新的成员添加，因此它们的数据成员直接保存在类里而没用 d-pointer。</p><ul><li>在Qt中，所有私有对象的基类是 <code>QObjectPrivate</code></li><li><code>Q_D</code>和<code>Q_Q</code> 宏提供了上边讨论的 QPTR 和 DPTR 的功能.</li><li>Qt 的公有类有一个 <code>Q_DECLARE_PRIVATE</code> 的宏。这个宏的代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// qlabel.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QLabel</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Q_DECLARE_PRIVATE</span>(QLabel);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// qglobal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Q_DECLARE_PRIVATE(Class) \</span></span><br><span class="line"><span class="meta">    inline Class##Private* d_func() \</span></span><br><span class="line"><span class="meta">    &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast<span class="string">&lt;Class##Private *&gt;</span>(qGetPtrHelper(d_ptr));) &#125; \</span></span><br><span class="line"><span class="meta">    inline const Class##Private* d_func() const \</span></span><br><span class="line"><span class="meta">    &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast<span class="string">&lt;const Class##Private *&gt;</span>(qGetPtrHelper(d_ptr));) &#125; \</span></span><br><span class="line"><span class="meta">    friend class Class##Private;</span></span><br></pre></td></tr></table></figure><p>这里的想法是 <code>QLabel</code> 提供了一个函数 <code>d_func()</code> 允许访问它的私有内部类。这个方法本身是私有的（因为这个宏定义在 qlabel.h 私有区域）。 但是 <code>d_func()</code> 可以被 <code>QLabel</code> 的 <em>友元函数</em> (C++ 友元)调用。这主要对一些 Qt 类想获得 <code>QLabel</code> 的无法通过公有 API 访问的一些信息有用。例如，<code>QLabel</code> 可能要跟踪用户点击了一个链接多少次。但是没有公有 API 访问这个信息。<code>QStatistics</code> 是需要这个信息的一个类。Qt开发人员可以添加 <code>QStatistics</code> 作为 <code>QLabel</code> 的一个友元类，这样<code>QStatistics</code> 就可以 <code>label-&gt;d_func()-&gt;linkClickCount</code> 来访问。</p><p><code>d_func</code> 还有一个优点是保证了const正确性：在 MyClass 的一个 const 成员函数里，你需要 Q_D(const MyClass)，因此你只能调用 MyClassPrivate 的const成员函数。如果用 “naked” 的 d_ptr 你可以调用非const函数。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test-Images-6</title>
      <link href="/2021/04/02/Hexo-Blog/Test-Images-6/"/>
      <url>/2021/04/02/Hexo-Blog/Test-Images-6/</url>
      
        <content type="html"><![CDATA[<h2 id="Test-Images-6">Test-Images-6</h2><p>测试图片显示</p><p><img src="/assets/images/%E5%A4%B4%E5%83%8F.jpg" alt="头像"></p><p><img src="/assets/images/arrow_top_hover.png" alt="arrow_top_hover"></p><p>Test-Images-6</p><p><img src="/assets/images/art-car.png" alt="art-car"></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test-Images-5</title>
      <link href="/2021/04/01/Hexo-Blog/Test-Images-5/"/>
      <url>/2021/04/01/Hexo-Blog/Test-Images-5/</url>
      
        <content type="html"><![CDATA[<h2 id="Test-Images-4-2">Test-Images-4</h2><p>测试图片显示</p><p>Test-Images-5</p><p><img src="/assets/images/art-car.png" alt="art-car"></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test-Images-4</title>
      <link href="/2021/04/01/Hexo-Blog/Test-Images-4/"/>
      <url>/2021/04/01/Hexo-Blog/Test-Images-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Test-Images-4">Test-Images-4</h2><p>测试图片显示</p><p><img src="/assets/images/nvm-install-nodejs-error.png" alt="nvm-install-nodejs-error"></p><p>Test-Images-4</p><p><img src="/assets/images/art.png" alt="art"></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test-Images-3</title>
      <link href="/2021/04/01/Hexo-Blog/Test-Images-3/"/>
      <url>/2021/04/01/Hexo-Blog/Test-Images-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Test-Images-3">Test-Images-3</h2><p>测试图片显示</p><p><img src="/assets/images/hexo-theme.png" alt="hexo-theme"></p><p>Test-Images-3</p><p><img src="/assets/images/refresh_hover.png" alt="hexo-themeTest-Images-3"></p><p>end.</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test-Images</title>
      <link href="/2021/04/01/Hexo-Blog/Test-images/"/>
      <url>/2021/04/01/Hexo-Blog/Test-images/</url>
      
        <content type="html"><![CDATA[<h2 id="Test-Images">Test-Images</h2><p>在另一个工作环境编写博客<br><img src="/assets/images/blog.png" alt="blog"><br>![blog-1]/images/(blog-1.png)<br><img src="/assets/images/blog-2.png" alt="blog-2"></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog-env </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Edit-Blog-With-Another-Workspace</title>
      <link href="/2021/04/01/Hexo-Blog/Edit-Blog-With-Another-Workspace/"/>
      <url>/2021/04/01/Hexo-Blog/Edit-Blog-With-Another-Workspace/</url>
      
        <content type="html"><![CDATA[<h2 id="Edit-Blog-With-Another-Workspace">Edit-Blog-With-Another-Workspace</h2><p>在另一个工作环境编写博客<br><img src="/assets/images/blog.png" alt="blog"><br><img src="/assets/images/blog-1.png" alt="blog-1"><br><img src="/assets/images/blog-2.png" alt="blog-2"></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog-env </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/03/01/Hexo-Blog/hello-world/"/>
      <url>/2021/03/01/Hexo-Blog/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
